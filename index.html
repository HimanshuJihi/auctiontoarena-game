<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auction to Arena: IPL 2026 Cricket Game - Play 3D Cricket Online</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Play Auction to Arena: IPL 2026, the best 3D online cricket game. Experience the IPL auction, build your dream team, and compete in realistic 3D matches. Free to play in your browser!">
    <meta name="keywords" content="IPL 2026, Cricket Game, 3D Cricket, Online Cricket, IPL Auction Game, WebGL Game, Sports Game, Cricket Simulator">
    <meta name="author" content="Auction to Arena Team">
    <meta name="robots" content="index, follow">
    <meta name="google-site-verification" content="ttR62D_WfNyTiaM26cpYCAsq40XCEqOuwfo1CC2ieJQ" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Auction to Arena: IPL 2026 Cricket Game">
    <meta property="og:description" content="Experience the thrill of the IPL 2026 auction and play realistic 3D cricket matches right in your browser.">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:title" content="Auction to Arena: IPL 2026 Cricket Game">
    <meta property="twitter:description" content="Experience the thrill of the IPL 2026 auction and play realistic 3D cricket matches right in your browser.">

    <!-- Link to external CSS -->
    <link rel="stylesheet" href="style.css">
    <!-- Suppress favicon.ico 404 error -->
    <link rel="icon" href="game-logo.png" type="image/png">
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4993635171115303"
     crossorigin="anonymous"></script>
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-6FBZXVMTR6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-6FBZXVMTR6');
    </script>
    
    <!-- Structured Data (JSON-LD) for SEO -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "VideoGame",
      "name": "Auction to Arena: IPL 2026",
      "description": "A 3D web-based cricket game featuring IPL 2026 auction simulation and realistic gameplay.",
      "genre": ["Sports", "Simulation", "Cricket"],
      "playMode": "SinglePlayer",
      "applicationCategory": "Game",
      "operatingSystem": "Web Browser",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
    </script>
    <style>
        /* Responsive & Mobile Adjustments */
        body { margin: 0; overflow: hidden; touch-action: none; user-select: none; -webkit-user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        canvas { display: block; width: 100%; height: 100%; }

        /* Responsive UI */
        .screen { width: 100% !important; height: 100% !important; max-width: 100% !important; padding: 20px !important; box-sizing: border-box; }
        h1 { font-size: clamp(1.5rem, 5vw, 3rem) !important; }
        h2 { font-size: clamp(1rem, 4vw, 2rem) !important; }
        .btn { padding: 10px 20px !important; font-size: clamp(0.8rem, 3vw, 1.2rem) !important; margin: 5px !important; touch-action: manipulation; }

        /* Mobile Touch Controls */
        #mobile-controls {
            display: none; /* Hidden on Desktop by default */
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 120px;
            pointer-events: none;
            z-index: 2000;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }

        /* Show controls on smaller screens */
        @media (max-width: 1024px) {
            #mobile-controls { display: flex; }
            #controls-hint { display: none !important; }
            #pause-btn, #exit-btn, #cam-btn, #master-sound-btn, #commentary-mute-btn, #crowd-mute-btn, #field-btn { bottom: 150px !important; top: auto !important; } /* Keep buttons accessible above controls */
        }

        /* Mobile Portrait Adjustments */
        @media (max-width: 600px) {
            /* Move Pause and Exit to top left to save space */
            #pause-btn { left: 10px !important; top: 10px !important; bottom: auto !important; }
            #exit-btn { left: 70px !important; top: 10px !important; bottom: auto !important; }

            /* Reposition utility buttons to the right side */
            #cam-btn { left: auto !important; right: 10px !important; bottom: 150px !important; }
            #field-btn { left: auto !important; right: 70px !important; bottom: 150px !important; }
            
            #master-sound-btn { left: auto !important; right: 10px !important; bottom: 210px !important; }
            #commentary-mute-btn { left: auto !important; right: 70px !important; bottom: 210px !important; }
            #crowd-mute-btn { left: auto !important; right: 130px !important; bottom: 210px !important; }
        }

        .control-btn {
            width: 60px; height: 60px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%; color: white; font-size: 24px; font-weight: bold;
            pointer-events: auto; display: flex; align-items: center; justify-content: center;
        }
        .control-btn:active { background: rgba(255, 255, 255, 0.4); transform: scale(0.95); }
        .big-btn { width: 80px; height: 80px; background: rgb(116, 118, 4); border-color: rgb(0, 0, 0); }
        .red-btn { background: rgba(1, 17, 109, 0.984); border-color: rgb(0, 0, 0); }
        
        .d-pad { display: flex; gap: 15px; align-items: flex-end; }
        .action-pad { display: flex; gap: 15px; align-items: flex-end; }

        /* Card Responsiveness */
        .auction-card, .summary-card { width: 95% !important; max-width: 500px !important; }

        /* Bowling Speedometer */
        #speedometer {
            display: none;
            position: absolute;
            bottom: 150px;
            left: 20px;
            width: 30px;
            height: 150px;
            background: rgba(0,0,0,0.5);
            border: 2px solid gold;
            border-radius: 10px;
            z-index: 2000;
            padding: 3px;
        }
        #speedo-bar {
            width: 100%;
            height: 0%;
            background: linear-gradient(to top, #4caf50, yellow, red);
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <!-- Main Menu -->
        <div id="menu-screen" class="screen active">
            <h1>Auction To Arena IPL 2026</h1>
            <h2>Next Gen 3D Web Game</h2>
            <button class="btn" id="btn-new-career">New Career</button>
            <button class="btn" id="btn-practice-mode">Practice Mode</button>
            <a href="news.html"><button class="btn">Cricket News</button></a>
            <button class="btn" id="btn-target-practice">Target Practice</button>
            <button class="btn" id="resume-btn" style="display:none;">Resume Career</button>
            <button class="btn btn-secondary" id="btn-settings">Settings</button>
            <button class="btn btn-secondary" id="btn-help">Help</button>
            <div style="margin-top: 20px;">
                <!-- Auction to arena -->
                <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-client="ca-pub-4993635171115303"
                     data-ad-slot="2735076524"
                     data-ad-format="auto"
                     data-full-width-responsive="true"></ins>
                <script>
                     (adsbygoogle = window.adsbygoogle || []).push({});
                </script>
            </div>
            <div id="footer-links" style="padding-top: 10px; text-align: center;">
                <a href="privacy.html" style="color: #aaa; margin: 0 15px; text-decoration: none;">Privacy Policy</a>
                <a href="terms.html" style="color: #aaa; margin: 0 15px; text-decoration: none;">Terms and Conditions</a>
                <a href="contact.html" style="color: #aaa; margin: 0 15px; text-decoration: none;">Contact Us</a>
            </div>
        </div>

        <!-- Practice Select Screen -->
        <div id="practice-select-screen" class="screen">
            <h1>Practice Mode</h1>
            <p>What would you like to practice?</p>
            <button class="btn" id="btn-practice-batting">Batting</button>
            <button class="btn" id="btn-practice-bowling">Bowling</button>
            <button class="btn btn-secondary" id="btn-back-from-practice-select">Back</button>
        </div>

        <!-- Team Select Screen -->
        <div id="team-select-screen" class="screen">
            <h1>Select Your Team</h1>
            <select id="team-dropdown" style="padding: 15px; font-size: 1.5rem; margin: 20px; background: #333; color: white; border: 1px solid gold;">
                <!-- Options populated by JS -->
            </select>
            <button class="btn" id="btn-confirm-team">Confirm & Go to Auction</button>
            <button class="btn btn-secondary" id="btn-back-from-team">Back</button>
        </div>

        <!-- Settings Screen -->
        <div id="settings-screen" class="screen">
            <h1>Settings</h1>
            <div style="width: 60%; margin: 0 auto; text-align: left;">
                <div style="margin-bottom: 20px;">
                    <label style="font-size: 1.5rem; display: block; margin-bottom: 10px;">Master Volume: <span id="vol-display">100%</span></label>
                    <input type="range" id="master-vol-slider" min="0" max="1" step="0.1" value="1" style="width: 100%;">
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="font-size: 1.5rem; display: block; margin-bottom: 10px;">Commentary Volume: <span id="commentary-vol-display">100%</span></label>
                    <input type="range" id="commentary-vol-slider" min="0" max="1" step="0.1" value="1" style="width: 100%;">
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="font-size: 1.5rem; display: block; margin-bottom: 10px;">Crowd Volume: <span id="crowd-vol-display">100%</span></label>
                    <input type="range" id="crowd-vol-slider" min="0" max="1" step="0.1" value="1" style="width: 100%;">
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="font-size: 1.5rem; display: block; margin-bottom: 10px;">Graphics Quality</label>
                    <select id="graphics-select" style="width: 100%; padding: 10px; font-size: 1.2rem; background: #333; color: white; border: 1px solid gold;">
                        <option value="high">High (Shadows + AA)</option>
                        <option value="medium">Medium (Basic Shadows)</option>
                        <option value="low">Low (No Shadows, Performance)</option>
                    </select>
                </div>
            </div>
            <button class="btn" id="btn-back-from-settings">Back</button>
        </div>

        <!-- Help Screen -->
        <div id="help-screen" class="screen">
            <h1>Help & Controls</h1>
            <div style="display: flex; justify-content: space-around; width: 90%; margin: 0 auto; text-align: left;">
                <div style="width: 45%;">
                    <h2 style="color: var(--accent-color);">Batting Controls</h2>
                    <ul style="font-size: 1.2rem; line-height: 1.6;">
                        <li><b>A / D</b>: Move Batsman Left/Right</li>
                        <li><b>Z</b>: Defensive Shot (Ground)</li>
                        <li><b>X / Space</b>: Lofted Shot (Air)</li>
                        <li><b>Arrow Keys</b>: Control Shot Direction (Hold while hitting)</li>
                    </ul>
                </div>
                <div style="width: 45%;">
                    <h2 style="color: #4caf50;">Bowling Controls</h2>
                    <ul style="font-size: 1.2rem; line-height: 1.6;">
                        <li><b>A / D</b>: Move Bowler Position</li>
                        <li><b>Space</b>: Start Run-up / Release Ball</li>
                        <li><b>Space</b>: Control Power, Aim, and Bowl</li>
                        <li><b>W/S/Arrows</b>: Control Aiming Marker</li>
                    </ul>
                </div>
            </div>
            <div style="margin-top: 20px; text-align: left; width: 90%; margin-left: auto; margin-right: auto;">
                <h2 style="color: gold;">Rules</h2>
                <p>1. <b>Wickets:</b> 10 wickets per innings.</p>
                <p>2. <b>Overs:</b> Selectable (2, 5, 10, 20).</p>
                <p>3. <b>No Ball:</b> Random chance. Free run + extra ball.</p>
                <p>4. <b>Wide:</b> Ball outside markers. Extra run + extra ball.</p>
            </div>
            <button class="btn" id="btn-back-from-help">Back</button>
        </div>

        <!-- Squad Screen -->
        <div id="squad-screen" class="screen">
            <h1>My Squad</h1>
            <div style="max-height: 500px; overflow-y: auto; width: 80%;">
                <table id="squad-table">
                    <thead><tr><th>Name</th><th>Role</th><th>Stats</th><th>Price (Cr)</th></tr></thead>
                    <tbody id="squad-body"></tbody>
                </table>
            </div>
            <button class="btn" id="btn-back-to-auction">Back to Auction</button>
        </div>

        <!-- Auction Screen -->
        <div id="auction-screen" class="screen">
            <h1>IPL Auction 2025</h1>
            
            <div class="auction-container">
                <!-- Main Auction Card -->
                <div class="auction-card">
                    <h2 id="auc-player-name">Player Name</h2>
                    <p id="auc-player-role" style="color: #aaa;">Role</p>
                    <div class="player-stats">
                        <span>Base Price: <span id="auc-base-price">2.0 Cr</span></span>
                    </div>
                    <div class="bid-log" id="auc-log">
                        <div>Auction starting...</div>
                    </div>
                    <div style="margin-top: 20px;">
                        <h3 style="color:var(--accent-color)">Current Bid: <span id="auc-current-bid">2.0 Cr</span></h3>
                        <h4 id="auc-current-holder">None</h4>
                    </div>
                    <button class="btn" id="btn-bid">BID (+25L)</button>
                    <button class="btn btn-secondary" id="btn-skip-player">SKIP</button>
                    
                    <div style="margin-top: 20px; display: flex; gap: 20px; justify-content: center;">
                        <h3>Budget: <span id="user-budget" style="color: #4caf50;">100.0 Cr</span></h3>
                        <h3>Squad: <span id="squad-count">0</span>/25</h3>
                    </div>
                </div>

                <!-- Live Squad Sidebar -->
                <div class="squad-sidebar">
                    <h3 style="color: var(--accent-color); border-bottom: 1px solid #555; padding-bottom: 10px; margin-top: 0;">Your Buys</h3>
                    <div id="auction-squad-list">
                        <!-- Items added here dynamically -->
                    </div>
                </div>
            </div>
            <div style="margin-top: 20px;">
                <button class="btn btn-secondary" style="font-size: 1rem;" id="btn-autofill-squad">Auto-Fill Squad</button>
                <button class="btn" style="font-size: 1rem; background: linear-gradient(45deg, #28a745, #1e7e34); border-color: #28a745;" id="btn-finish-auction">Skip & Play Match</button>
            </div>
        </div>

        <!-- Toss Screen -->
        <div id="toss-screen" class="screen">
            <h1>Toss Time</h1>
            <h2 id="toss-match-title">MI vs CSK</h2>
            <div id="toss-coin-section">
                <p style="font-size: 1.5rem;">Call the coin:</p>
                <button class="btn" id="btn-toss-heads">Heads</button>
                <button class="btn" id="btn-toss-tails">Tails</button>
            </div>
            <div id="toss-decision-section" style="display:none;">
                <h2 id="toss-result-text" style="color: gold;"></h2>
                <div id="user-decision-buttons" style="display:none;">
                    <p>You Won the Toss! Choose:</p>
                    <button class="btn" id="btn-decision-bat">Bat</button>
                    <button class="btn" id="btn-decision-bowl">Bowl</button>
                </div>
                <div id="ai-decision-text" style="display:none;">
                    <p id="ai-decision-msg" style="font-size: 1.5rem; margin: 20px;"></p>
                    <button class="btn" id="btn-start-match-from-toss">Start Match</button>
                </div>
            </div>
        </div>

        <!-- Tournament Hub -->
        <div id="tournament-screen" class="screen">
            <h1>IPL 2025 Tournament</h1>
            <h2 id="user-team-title">Your Team</h2>
            <div style="max-height: 600px; overflow-y: auto; width: 100%; display: flex; justify-content: center;">
                <table id="points-table">
                    <thead><tr><th>Pos</th><th>Team</th><th>P</th><th>W</th><th>L</th><th>Pts</th><th>NRR</th></tr></thead>
                    <tbody id="points-body"></tbody>
                </table>
            </div>
            <div style="margin: 20px;">
                <label style="font-size: 1.5rem; color: var(--accent-color);">Select Overs: </label>
                <select id="overs-select" style="padding: 10px; font-size: 1.2rem; background: #333; color: white; border: 1px solid gold;">
                    <option value="2">2 Overs</option>
                    <option value="5">5 Overs</option>
                    <option value="10">10 Overs</option>
                    <option value="20">20 Overs</option>
                </select>
                <label style="font-size: 1.5rem; color: var(--accent-color); margin-left: 20px;">Time: </label>
                <select id="time-select" style="padding: 10px; font-size: 1.2rem; background: #333; color: white; border: 1px solid gold;">
                    <option value="day">Day</option>
                    <option value="night">Night</option>
                </select>
            </div>
            <button id="tournament-action-btn" class="btn">Play Next Match</button>
        </div>

        <!-- Playing 11 Selection -->
        <div id="playing11-screen" class="screen">
            <h1>Select Playing 11</h1>
            <p>Select 11 players from your squad for this match.</p>
            <div id="p11-list" class="player-select-grid"></div>
            <button class="btn" id="btn-confirm-p11">Confirm Playing 11</button>
        </div>

        <!-- Batsman Selection (Openers / Next Wicket) -->
        <div id="batsman-select-screen" class="screen">
            <h1 id="batsman-select-title">Select Openers</h1>
            <div style="display: flex; gap: 20px; width: 80%; justify-content: center;">
                <div style="width: 45%;">
                    <h3>Available Players</h3>
                    <div id="bat-select-list" style="display: flex; flex-direction: column; gap: 10px;"></div>
                </div>
                <div style="width: 45%; border-left: 1px solid #555; padding-left: 20px;">
                    <h3 id="selection-instruction">Select Striker</h3>
                    <div id="current-selection-display" style="font-size: 1.5rem; color: var(--accent-color); margin: 20px;">None</div>
                    <button class="btn" id="confirm-batsman-btn">Confirm</button>
                </div>
            </div>
        </div>

        <!-- Bowler Selection Screen -->
        <div id="bowler-select-screen" class="screen">
            <h1>Select Bowler</h1>
            <div style="display: flex; gap: 20px; width: 80%; justify-content: center;">
                <div style="width: 45%;">
                    <h3>Available Bowlers</h3>
                    <div id="bowl-select-list" style="display: flex; flex-direction: column; gap: 10px;"></div>
                </div>
                <div style="width: 45%; border-left: 1px solid #555; padding-left: 20px;">
                    <h3>Selected Bowler</h3>
                    <div id="current-bowler-display" style="font-size: 1.5rem; color: var(--accent-color); margin: 20px;">None</div>
                    <button class="btn" id="btn-confirm-bowler">Confirm</button>
                </div>
            </div>
        </div>

        <!-- Match Summary Screen -->
        <div id="summary-screen" class="screen">
            <h1>Match Summary</h1>
            <div class="summary-card">
                <h2 id="summary-result" style="font-size: 3rem; color: gold; margin: 10px 0;">You Won!</h2>
                <div style="display: flex; justify-content: space-around; width: 100%; margin: 30px 0; border-top: 1px solid #444; border-bottom: 1px solid #444; padding: 20px 0;">
                    <div>
                        <h3 style="color: var(--primary-color);">Your Score</h3>
                        <p id="summary-user-score" style="font-size: 2.5rem; margin: 5px;">120/3</p>
                    </div>
                    <div>
                        <h3 style="color: #aaa;">Opponent</h3>
                        <p id="summary-opp-score" style="font-size: 2.5rem; margin: 5px;">115/5</p>
                    </div>
                </div>
                <div id="summary-stats" style="font-size: 1.2rem; color: #ddd; margin-bottom: 20px;"></div>
                <button class="btn" id="btn-continue-tournament">Continue Tournament</button>
            </div>
        </div>

        <!-- Game HUD -->
        <div id="hud">
            <button id="pause-btn" style="position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.5); color: white; border: 1px solid gold; border-radius: 50%; width: 50px; height: 50px; font-size: 1.5rem; cursor: pointer; z-index: 1000; pointer-events: auto;">II</button>
            <button id="exit-btn" style="position: absolute; bottom: 20px; left: 80px; background: rgba(221, 31, 45, 0.8); color: white; border: 1px solid white; border-radius: 5px; height: 50px; padding: 0 15px; font-size: 1.2rem; cursor: pointer; z-index: 1000; pointer-events: auto;">EXIT</button>
            <button id="cam-btn" style="position: absolute; bottom: 20px; left: 150px; background: rgba(0,0,0,0.5); color: white; border: 1px solid gold; border-radius: 50%; width: 50px; height: 50px; font-size: 1.5rem; cursor: pointer; z-index: 1000; pointer-events: auto;">üé•</button>
            <button id="master-sound-btn" style="position: absolute; bottom: 20px; left: 210px; background: rgba(0,0,0,0.5); color: white; border: 1px solid gold; border-radius: 50%; width: 50px; height: 50px; font-size: 1.5rem; cursor: pointer; z-index: 1000; pointer-events: auto;">üîä</button>
            <button id="commentary-mute-btn" style="position: absolute; bottom: 20px; left: 270px; background: rgba(0,0,0,0.5); color: white; border: 1px solid gold; border-radius: 50%; width: 50px; height: 50px; font-size: 1.5rem; cursor: pointer; z-index: 1000; pointer-events: auto;">üó£Ô∏è</button>
            <button id="crowd-mute-btn" style="position: absolute; bottom: 20px; left: 330px; background: rgba(0,0,0,0.5); color: white; border: 1px solid gold; border-radius: 50%; width: 50px; height: 50px; font-size: 1.5rem; cursor: pointer; z-index: 1000; pointer-events: auto;">üèüÔ∏è</button>
            <button id="field-btn" style="position: absolute; bottom: 20px; left: 390px; background: rgba(0,0,0,0.5); color: white; border: 1px solid gold; border-radius: 50%; width: 50px; height: 50px; font-size: 1.5rem; cursor: pointer; z-index: 1000; pointer-events: auto; display: none;">üéΩ</button>
            <div class="score-board" style="position: relative;">
                <div style="text-align: left;">
                    <div id="match-teams" style="font-size: 1.2rem; color: #aaa;">MI vs CSK</div>
                    <div id="match-status" style="font-size: 1rem; color: var(--primary-color);">1st Innings</div>
                </div>
                
                <div style="text-align: center;">
                    <div class="score-main"><span id="score-runs">0</span> - <span id="score-wickets">0</span></div>
                    <div style="font-size: 1.2rem;">Overs: <span id="score-overs">0.0</span></div>
                </div>

                <div class="score-details">
                    <div id="striker-name" style="color: var(--accent-color); font-weight: bold;">Striker *</div>
                    <div id="non-striker-name">Non-Striker</div>
                    <div id="bowler-name" style="color: #4caf50; border-top: 1px solid #555; margin-top: 5px; padding-top: 5px; font-size: 0.9rem;"></div>
                </div>
            </div>
        </div>
        <div id="controls-hint">
            <h3>CONTROLS</h3>
            <p>Move: <b>A / D</b></p>
            <p>Defensive: <b>Z</b></p>
            <p>Lofted: <b>X</b> or <b>Space</b></p>
            <p><i>Shot Direction: Hold Arrow Keys while hitting</i></p>
            <p id="bowling-controls" style="display:none; border-top: 1px solid #555; margin-top:5px; padding-top:5px;">Bowl: <b>Space</b></p>
        </div>
        <div id="commentary"></div>

        <!-- Bowling Speedometer -->
        <div id="speedometer">
            <div id="speedo-bar"></div>
        </div>

        <!-- Bowling Variations (Fast Bowler) -->
        <div id="bowling-controls-ui" style="display: none; position: absolute; top: 50%; right: 20px; transform: translateY(-50%); z-index: 1000; flex-direction: column; gap: 10px;">
            <button class="btn" id="btn-normal" style="font-size: 1rem; padding: 5px 10px; border-color: gold;">Normal</button>
            <button class="btn" id="btn-inswing" style="font-size: 1rem; padding: 5px 10px;">In Swing</button>
            <button class="btn" id="btn-outswing" style="font-size: 1rem; padding: 5px 10px;">Out Swing</button>
            <button class="btn" id="btn-slower" style="font-size: 1rem; padding: 5px 10px;">Slower</button>
        </div>

        <!-- Mobile Controls Overlay -->
        <div id="mobile-controls">
            <div class="d-pad">
                <div class="control-btn" id="btn-left">‚Üê</div>
                <div class="control-btn" id="btn-right">‚Üí</div>
            </div>
            <div class="action-pad">
                <div class="control-btn red-btn" id="btn-ground">DEF</div>
                <div class="control-btn big-btn" id="btn-loft">HIT</div>
            </div>
        </div>
        <div id="countdown-overlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; justify-content: center; align-items: center; font-size: 15vw; color: white; text-shadow: 3px 3px 10px #000; background-color: rgba(0,0,0,0.4); z-index: 3000;">
            5
        </div>
    </div>
        

    <script>
        // --- AdSense Interstitial Trigger ---
        function triggerInterstitialAd() {
            console.log("Interstitial ad requested. AdSense will show an ad if available and configured.");
            // This function is a placeholder for triggering a page-level ad (vignette).
            // You must enable Vignette ads in your AdSense account for this to have an effect.
            // Pushing an empty object can signal to AdSense that a new "view" has occurred.
            try {
                (adsbygoogle = window.adsbygoogle || []).push({});
            } catch (e) {
                console.error("Interstitial ad push error:", e);
            }
        }

        //** Global Error Handler for better debugging
        // window.onerror = function(message, source, lineno, colno, error) {
        //    console.error("Global Error Caught:", { message, source, lineno, colno, error });
         //   alert("An unexpected error occurred! Please check the console (F12) for details.");
          //   return true; // Prevent default error handling
        // } 


        // --- DATA: IPL Teams & 2025 Auction Players ---
        const TEAMS = [
            { id: 'MI', name: 'Mumbai Indians', color: 0x004BA0, jersey: { front: 'mi1.jpg', back: 'mi2.jpg', trousersBat: 'mi4.jpg', trousersField: 'mi3.jpg' }, played: 0, won: 0, pts: 0, runsScored: 0, ballsFaced: 0, runsConceded: 0, ballsBowled: 0 },
            { id: 'CSK', name: 'Chennai Super Kings', color: 0xFFFF3C, jersey: { front: 'csk1.jpg', back: 'csk2.jpg', trousersBat: 'csk4.jpg', trousersField: 'csk3.jpg' }, played: 0, won: 0, pts: 0, runsScored: 0, ballsFaced: 0, runsConceded: 0, ballsBowled: 0 },
            { id: 'RCB', name: 'Royal Challengers Bangalore', color: 0xEC1C24, jersey: { front: 'rcb1.jpg', back: 'rcb2.jpg', trousersBat: 'rcb4.jpg', trousersField: 'rcb3.jpg' }, played: 0, won: 0, pts: 0, runsScored: 0, ballsFaced: 0, runsConceded: 0, ballsBowled: 0 },
            { id: 'KKR', name: 'Kolkata Knight Riders', color: 0x3A225D, jersey: { front: 'kkr1.jpg', back: 'kkr2.jpg', trousersBat: 'kkr4.jpg', trousersField: 'kkr3.jpg' }, played: 0, won: 0, pts: 0, runsScored: 0, ballsFaced: 0, runsConceded: 0, ballsBowled: 0 },
            { id: 'GT', name: 'Gujarat Titans', color: 0x1B2133, jersey: { front: 'gt1.jpg', back: 'gt2.jpg', trousersBat: 'gt4.jpg', trousersField: 'gt3.jpg' }, played: 0, won: 0, pts: 0, runsScored: 0, ballsFaced: 0, runsConceded: 0, ballsBowled: 0 },
            { id: 'SRH', name: 'Sunrisers Hyderabad', color: 0xFF822A, jersey: { front: 'srh1.jpg', back: 'srh2.jpg', trousersBat: 'srh4.jpg', trousersField: 'srh3.jpg' }, played: 0, won: 0, pts: 0, runsScored: 0, ballsFaced: 0, runsConceded: 0, ballsBowled: 0 },
            { id: 'LSG', name: 'Lucknow Super Giants', color: 0x0057E0, jersey: { front: 'lsg1.jpg', back: 'lsg2.jpg', trousersBat: 'lsg4.jpg', trousersField: 'lsg3.jpg' }, played: 0, won: 0, pts: 0, runsScored: 0, ballsFaced: 0, runsConceded: 0, ballsBowled: 0 },
            { id: 'DC', name: 'Delhi Capitals', color: 0x00008B, jersey: { front: 'dc1.jpg', back: 'dc2.jpg', trousersBat: 'dc4.jpg', trousersField: 'dc3.jpg' }, played: 0, won: 0, pts: 0, runsScored: 0, ballsFaced: 0, runsConceded: 0, ballsBowled: 0 },
            { id: 'PBKS', name: 'Punjab Kings', color: 0xDD1F2D, jersey: { front: 'pbks1.jpg', back: 'pbks2.jpg', trousersBat: 'pbks4.jpg', trousersField: 'pbks3.jpg' }, played: 0, won: 0, pts: 0, runsScored: 0, ballsFaced: 0, runsConceded: 0, ballsBowled: 0 },
            { id: 'RR', name: 'Rajasthan Royals', color: 0xEA1A85, jersey: { front: 'rr1.jpg', back: 'rr2.jpg', trousersBat: 'rr4.jpg', trousersField: 'rr3.jpg' }, played: 0, won: 0, pts: 0, runsScored: 0, ballsFaced: 0, runsConceded: 0, ballsBowled: 0 }
        ];

        // Expanded Player List for Demo
        const STAR_PLAYERS = [
            { name: "Rishabh Pant", role: "Wicketkeeper Batter", base: 2.0, jerseyNumber: 17, handedness: 'left', bowlingStyle: null },
            { name: "KL Rahul", role: "Batter", base: 2.0, jerseyNumber: 1, handedness: 'right' },
            { name: "Shreyas Iyer", role: "Batter", base: 2.0, jerseyNumber: 41, handedness: 'right' },
            { name: "Ben Stokes", role: "All-Rounder", base: 2.0, jerseyNumber: 55, handedness: 'left', bowlingStyle: 'Fast' },
            { name: "Arshdeep Singh", role: "Bowler", base: 2.0, jerseyNumber: 2, handedness: 'left', bowlingStyle: 'Fast' },
            { name: "Jos Buttler", role: "Batter", base: 2.0, jerseyNumber: 63, handedness: 'right' },
            { name: "Mohammed Shami", role: "Bowler", base: 2.0, jerseyNumber: 11, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Ishan Kishan", role: "Wicketkeeper Batter", base: 2.0, jerseyNumber: 28, handedness: 'left' },
            { name: "Yuzvendra Chahal", role: "Bowler", base: 2.0, jerseyNumber: 3, handedness: 'right', bowlingStyle: 'Spin' },
            { name: "Jofra Archer", role: "Bowler", base: 2.0, jerseyNumber: 22, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Rachin Ravindra", role: "All-Rounder", base: 1.5, jerseyNumber: 80, handedness: 'left', bowlingStyle: 'Spin' },
            { name: "Travis Head", role: "Batter", base: 2.0, jerseyNumber: 62, handedness: 'left' },
            { name: "Gerald Coetzee", role: "Bowler", base: 1.5, jerseyNumber: 60, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "David Warner", role: "Batter", base: 2.0, jerseyNumber: 31, handedness: 'left' },
            { name: "Trent Boult", role: "Bowler", base: 2.0, jerseyNumber: 78, handedness: 'left', bowlingStyle: 'Fast' },
            { name: "Glenn Maxwell", role: "All-Rounder", base: 2.0, jerseyNumber: 34, handedness: 'right', bowlingStyle: 'Spin' },
            { name: "Kagiso Rabada", role: "Bowler", base: 2.0, jerseyNumber: 25, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Quinton de Kock", role: "Wicketkeeper Batter", base: 2.0, jerseyNumber: 42, handedness: 'left' },
            { name: "Sam Curran", role: "All-Rounder", base: 2.0, jerseyNumber: 58, handedness: 'left', bowlingStyle: 'Fast' },
            { name: "Liam Livingstone", role: "All-Rounder", base: 2.0, jerseyNumber: 23, handedness: 'right', bowlingStyle: 'Spin' },
            { name: "Rohit Sharma", role: "Batter", base: 2.0, jerseyNumber: 45, handedness: 'right', bowlingStyle: 'Spin' },
            { name: "Virat Kohli", role: "Batter", base: 2.0, jerseyNumber: 18, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Jasprit Bumrah", role: "Bowler", base: 2.0, jerseyNumber: 93, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Suryakumar Yadav", role: "Batter", base: 2.0, jerseyNumber: 68, handedness: 'right' },
            { name: "Hardik Pandya", role: "All-Rounder", base: 2.0, jerseyNumber: 33, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Ravindra Jadeja", role: "All-Rounder", base: 2.0, jerseyNumber: 8, handedness: 'left', bowlingStyle: 'Spin' },
            { name: "Shubman Gill", role: "Batter", base: 2.0, jerseyNumber: 77, handedness: 'right' },
            { name: "Rashid Khan", role: "Bowler", base: 2.0, jerseyNumber: 19, handedness: 'right', bowlingStyle: 'Spin' },
            { name: "Pat Cummins", role: "Bowler", base: 2.0, jerseyNumber: 30, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Mitchell Starc", role: "Bowler", base: 2.0, jerseyNumber: 56, handedness: 'left', bowlingStyle: 'Fast' },
            { name: "Abhishek Sharma", role: "Batter", base: 2.0, jerseyNumber: 98, handedness: 'left' },
            { name: "MS Dhoni", role: "Wicketkeeper Batter", base: 2.0, jerseyNumber: 7, handedness: 'right' },
            { name: "Kane Williamson", role: "Batter", base: 2.0, jerseyNumber: 22, handedness: 'right' },
            { name: "Steve Smith", role: "Batter", base: 2.0, jerseyNumber: 49, handedness: 'right' },
            { name: "Joe Root", role: "Batter", base: 1.5, jerseyNumber: 66, handedness: 'right' },
            { name: "Faf du Plessis", role: "Batter", base: 2.0, jerseyNumber: 13, handedness: 'right' },
            { name: "Andre Russell", role: "All-Rounder", base: 2.0, jerseyNumber: 12, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Sunil Narine", role: "All-Rounder", base: 2.0, jerseyNumber: 74, handedness: 'left', bowlingStyle: 'Spin' },
            { name: "Axar Patel", role: "All-Rounder", base: 2.0, jerseyNumber: 20, handedness: 'left', bowlingStyle: 'Spin' },
            { name: "Kuldeep Yadav", role: "Bowler", base: 2.0, jerseyNumber: 14, handedness: 'left', bowlingStyle: 'Spin' },
            { name: "Mohammed Siraj", role: "Bowler", base: 2.0, jerseyNumber: 73, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Bhuvneshwar Kumar", role: "Bowler", base: 2.0, jerseyNumber: 15, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Shikhar Dhawan", role: "Batter", base: 2.0, jerseyNumber: 91, handedness: 'left' },
            { name: "Ruturaj Gaikwad", role: "Batter", base: 2.0, jerseyNumber: 86, handedness: 'right' },
            { name: "Yashasvi Jaiswal", role: "Batter", base: 2.0, jerseyNumber: 67, handedness: 'left' },
            { name: "Rinku Singh", role: "Batter", base: 1.5, jerseyNumber: 35, handedness: 'left' },
            { name: "Tilak Varma", role: "Batter", base: 1.5, jerseyNumber: 9, handedness: 'left' },
            { name: "Cameron Green", role: "All-Rounder", base: 2.0, jerseyNumber: 57, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Marcus Stoinis", role: "All-Rounder", base: 2.0, jerseyNumber: 76, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Nicholas Pooran", role: "Wicketkeeper Batter", base: 2.0, jerseyNumber: 29, handedness: 'left' },
            { name: "Shimron Hetmyer", role: "Batter", base: 2.0, jerseyNumber: 189, handedness: 'left' },
            { name: "Tim David", role: "Batter", base: 2.0, jerseyNumber: 39, handedness: 'right' },
            { name: "Wanindu Hasaranga", role: "All-Rounder", base: 2.0, jerseyNumber: 40, handedness: 'right', bowlingStyle: 'Spin' },
            { name: "Maheesh Theekshana", role: "Bowler", base: 1.5, jerseyNumber: 61, handedness: 'right', bowlingStyle: 'Spin' },
            { name: "Matheesha Pathirana", role: "Bowler", base: 1.5, jerseyNumber: 81, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Lockie Ferguson", role: "Bowler", base: 2.0, jerseyNumber: 69, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Devon Conway", role: "Batter", base: 2.0, jerseyNumber: 88, handedness: 'left' },
            { name: "Aiden Markram", role: "Batter", base: 2.0, jerseyNumber: 92, handedness: 'right' },
            { name: "Heinrich Klaasen", role: "Wicketkeeper Batter", base: 2.0, jerseyNumber: 87, handedness: 'right' },
            { name: "Marco Jansen", role: "All-Rounder", base: 1.5, jerseyNumber: 72, handedness: 'left', bowlingStyle: 'Fast' },
            { name: "Anrich Nortje", role: "Bowler", base: 2.0, jerseyNumber: 95, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Lungi Ngidi", role: "Bowler", base: 1.5, jerseyNumber: 24, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Mitchell Marsh", role: "All-Rounder", base: 2.0, jerseyNumber: 85, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "David Miller", role: "Batter", base: 2.0, jerseyNumber: 10, handedness: 'left' },
            { name: "Jonny Bairstow", role: "Wicketkeeper Batter", base: 2.0, jerseyNumber: 51, handedness: 'right' },
            { name: "Daryl Mitchell", role: "All-Rounder", base: 1.5, jerseyNumber: 75, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Riyan Parag", role: "Batter", base: 1.5, jerseyNumber: 43, handedness: 'right' },
            { name: "T. Natarajan", role: "Bowler", base: 2.0, jerseyNumber: 44, handedness: 'left', bowlingStyle: 'Fast' },
            { name: "Deepak Chahar", role: "Bowler", base: 2.0, jerseyNumber: 90, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Shardul Thakur", role: "All-Rounder", base: 2.0, jerseyNumber: 54, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Washington Sundar", role: "All-Rounder", base: 1.5, jerseyNumber: 5, handedness: 'left', bowlingStyle: 'Spin' },
            { name: "Ishant Sharma", role: "Bowler", base: 1.5, jerseyNumber: 97, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Umesh Yadav", role: "Bowler", base: 1.5, jerseyNumber: 71, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Mohit Sharma", role: "Bowler", base: 1.5, jerseyNumber: 38, handedness: 'right', bowlingStyle: 'Fast' },
            { name: "Piyush Chawla", role: "Bowler", base: 1.5, jerseyNumber: 36, handedness: 'right', bowlingStyle: 'Spin' },
            { name: "Amit Mishra", role: "Bowler", base: 1.0, jerseyNumber: 99, handedness: 'right', bowlingStyle: 'Spin' },
            { name: "Ajinkya Rahane", role: "Batter", base: 1.5, jerseyNumber: 27, handedness: 'right' },
            { name: "Nitish Rana", role: "Batter", base: 1.5, jerseyNumber: 37, handedness: 'left' },
            { name: "Venkatesh Iyer", role: "All-Rounder", base: 2.0, jerseyNumber: 94, handedness: 'left', bowlingStyle: 'Fast' },
            { name: "Varun Chakravarthy", role: "Bowler", base: 2.0, jerseyNumber: 89, handedness: 'right', bowlingStyle: 'Spin' },
            { name: "Rahul Tripathi", role: "Batter", base: 1.5, jerseyNumber: 52, handedness: 'right' },
            { name: "Mayank Agarwal", role: "Batter", base: 1.5, jerseyNumber: 16, handedness: 'right' },
            { name: "Prithvi Shaw", role: "Batter", base: 1.5, jerseyNumber: 100, handedness: 'right' },
            { name: "Sarfaraz Khan", role: "Batter", base: 1.0, jerseyNumber: 96, handedness: 'right' },
            { name: "Dhruv Jurel", role: "Wicketkeeper Batter", base: 1.5, jerseyNumber: 59, handedness: 'right' },
            { name: "Jitesh Sharma", role: "Wicketkeeper Batter", base: 1.5, jerseyNumber: 6, handedness: 'right' },
            { name: "Prabhsimran Singh", role: "Wicketkeeper Batter", base: 1.0, jerseyNumber: 84, handedness: 'left' },
            { name: "Shahrukh Khan", role: "Batter", base: 1.5, jerseyNumber: 47, handedness: 'right' },
            { name: "Rahul Tewatia", role: "All-Rounder", base: 1.5, jerseyNumber: 21, handedness: 'left', bowlingStyle: 'Spin' },
            { name: "Sai Sudharsan", role: "Batter", base: 1.5, jerseyNumber: 26, handedness: 'left' },
            { name: "Noor Ahmad", role: "Bowler", base: 1.5, jerseyNumber: 50, handedness: 'right', bowlingStyle: 'Spin' },
            { name: "Will Jacks", role: "All-Rounder", base: 1.5, jerseyNumber: 64, handedness: 'right', bowlingStyle: 'Spin' }
        ];

        function generateFullPlayerList() {
            const roles = ["Batter", "Bowler", "All-Rounder", "Wicketkeeper Batter"];
            const firstNames = ["Rahul", "Amit", "Vijay", "Sandeep", "Manoj", "Aditya", "Karan", "Arjun", "Vikram", "Rohan", "Suresh", "Dinesh", "Nitin", "Pradeep", "Raj", "Kamal", "Deepak", "Anil", "Sunil", "Ravi", "Akash", "Varun", "Nikhil", "Siddharth", "Mayank", "Ishaan", "Pranav", "Harsh", "Ankit", "Manish"];
            const lastNames = ["Sharma", "Verma", "Singh", "Yadav", "Gupta", "Malik", "Kumar", "Reddy", "Patel", "Iyer", "Nair", "Menon", "Das", "Roy", "Biswas", "Chopra", "Mehra", "Kapoor", "Khanna", "Jain", "Agarwal", "Bhatia", "Saxena", "Kaul", "Joshi", "Deshmukh", "Pawar", "Gowda", "Rao", "Reddy"];
            let list = JSON.parse(JSON.stringify(STAR_PLAYERS)); // Deep copy to avoid modifying original
            const usedNumbers = new Set(list.map(p => p.jerseyNumber));
            let nextJerseyNumber = 1;

            while(list.length < 250) { 
                let num;
                // This new logic prevents an infinite loop. Instead of picking a random number from a small
                // pool (1-99), it now finds the next available integer, which is guaranteed to terminate.
                do {
                    num = nextJerseyNumber++;
                } while (usedNumbers.has(num));
                usedNumbers.add(num);

                list.push({ 
                    name: `${firstNames[Math.floor(Math.random()*firstNames.length)]} ${lastNames[Math.floor(Math.random()*lastNames.length)]}`, 
                    role: roles[Math.floor(Math.random()*roles.length)], 
                    base: parseFloat((Math.random()*1.5+0.2).toFixed(2)),
                    jerseyNumber: num,
                    handedness: Math.random() < 0.5 ? 'left' : 'right'
                }); 
            }
            
            // Add Attributes
            return list.map(p => {
                let minP, maxP;
                // Stats based on Role
                const isBowler = p.role === "Bowler" || p.role === "All-Rounder";
                if (p.role === "Batter") { minP = 95; maxP = 99; }
                else if (p.role === "Wicketkeeper Batter") { minP = 90; maxP = 95; }
                else if (p.role === "All-Rounder") { minP = 85; maxP = 95; }
                else if (p.role === "Bowler") { minP = 30; maxP = 50; }
                else { minP = 50; maxP = 70; }

                return {
                    ...p,
                    power: Math.floor(Math.random() * (maxP - minP + 1)) + minP,
                    timing: Math.floor(Math.random() * (maxP - minP + 1)) + minP,
                    bowlingStyle: isBowler ? (Math.random() < 0.6 ? 'Fast' : 'Spin') : null // 60% fast bowlers
                };
            });
        }
        const PLAYERS_2025 = generateFullPlayerList();

        // --- NEW: Fielding Formations ---
        const FIELD_PLACEMENTS = {
            'Default': [ // Standard balanced field
                {x: 0, z: 12},      // Wicket-Keeper
                {x: 6, z: 15},      // Slip
                {x: 30, z: 10},     // Point
                {x: -30, z: 10},    // Cover
                {x: 15, z: -10},    // Mid-off
                {x: -15, z: -10},   // Mid-on
                {x: 45, z: -35},    // Deep Point
                {x: -45, z: -35},   // Deep Mid-wicket
                {x: 0, z: -50},     // Long Off
                {x: -20, z: -45},   // Long On
            ],
            'Defensive': [ // Saving boundaries
                {x: 0, z: 12},      // Wicket-Keeper
                {x: 40, z: 20},     // Third Man
                {x: -40, z: 20},    // Fine Leg
                {x: 50, z: -30},    // Deep Cover Point
                {x: -50, z: -30},   // Deep Square Leg
                {x: 0, z: -55},     // Long Off
                {x: 25, z: -55},    // Deep Extra Cover
                {x: -25, z: -55},   // Deep Mid-wicket
                {x: 60, z: 0},      // Sweeper Cover
                {x: -60, z: 0},     // Deep Square Leg
            ],
            'Aggressive': [ // Attacking field, slips and close-in
                {x: 0, z: 12},      // Wicket-Keeper
                {x: 5, z: 15}, {x: -5, z: 15}, {x: 10, z: 15}, // 3 Slips
                {x: -10, z: 15},    // Gully
                {x: 25, z: 5}, {x: -25, z: 5}, // Cover Point / Cover
                {x: 15, z: -5}, {x: -15, z: -5}, // Silly Mid-off / Silly Mid-on
                {x: -12, z: 10},    // Short Leg
            ],
            'Powerplay': [ // Inner circle restrictions
                {x: 0, z: 12},      // Wicket-Keeper
                {x: 6, z: 15},      // Slip
                {x: 25, z: 10},     // Point (Inner)
                {x: -25, z: 10},    // Cover (Inner)
                {x: 15, z: -10},    // Mid-off (Inner)
                {x: -15, z: -10},   // Mid-on (Inner)
                {x: -25, z: -5},    // Mid-wicket (Inner)
                {x: 25, z: 5},      // Square Leg (Inner)
                {x: 20, z: 20},     // Third Man (Short)
                {x: -20, z: 20},    // Fine Leg (Short)
            ],
            'Leg Side Attack': [ // Spin/Short ball trap
                {x: 0, z: 12},      // Wicket-Keeper
                {x: -6, z: 15},     // Leg Slip
                {x: -10, z: 5},     // Short Leg
                {x: -50, z: 5},     // Deep Square Leg
                {x: -45, z: -35},   // Deep Mid Wicket
                {x: -20, z: -45},   // Long On
                {x: -15, z: -10},   // Mid On
                {x: 30, z: 10},     // Point
                {x: -30, z: 10},    // Cover
                {x: 40, z: 20},     // Third Man
            ]
        };

        // --- SYSTEM: Audio Manager (Web Audio API) ---
        class SoundManager {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)(); // Ensure context is resumed on user interaction
                this.masterVolume = 1.0;
                this.commentaryVolume = 1.0;
                this.crowdVolume = 1.0;
                
                const loadAudio = (src, loop = false) => {
                    const a = new Audio(src);
                    a.loop = loop;
                    a.onerror = () => console.warn("Audio Load Error: " + src + " not found. Ensure file is in the same folder and name matches.");
                    return a;
                };

                // Background Crowd Loop
                this.crowdLoop = loadAudio('crowd.wav', true);
                if(this.crowdLoop) this.crowdLoop.volume = 0; // Start silent, will be set by updateVolume

                // Define which sounds are commentary
                this.commentaryCategories = [
                    'umpireOut', 'umpireNotOut', 'umpireWide', 'umpireNoBall', 'win',
                    'playerYes', 'playerNo', 'playerWait'
                ];
                
                // Define which sounds are gameplay (non-commentary, non-crowd)
                this.gameplayCategories = [
                    'six', 'four', 'wicket', 'caught'
                ];
                
                // Load Custom Audio Files
                this.sounds = {
                    six: [
                        loadAudio('Six1.wav'), loadAudio('Six2.wav'), loadAudio('Six3.wav'), loadAudio('Six4.wav')
                    ],
                    four: [
                        loadAudio('Four1.wav'), loadAudio('Four2.wav'), loadAudio('Four3.wav'), loadAudio('Four4.wav')
                    ],
                    wicket: [
                        loadAudio('Wicket1.wav'), loadAudio('Wicket2.wav')
                    ],
                    caught: [
                        loadAudio('Caught1.wav')
                    ],
                    umpireOut: [loadAudio('out.wav')],
                    umpireNotOut: [loadAudio('notout.wav')],
                    umpireWide: [loadAudio('wideball.wav')],
                    umpireNoBall: [loadAudio('noball.wav')],
                    win: [
                        loadAudio('Win1.wav'), loadAudio('Win2.wav'), loadAudio('Win3.wav')
                    ],
                    playerYes: [loadAudio('yes.wav')],
                    playerNo: [loadAudio('no.wav')],
                    playerWait: [loadAudio('wait.wav')]
                };

                // Unlock Audio on first user interaction (Fix for "Audio nahi aa rahi")
                this.unlocked = false;
                const unlockAudio = () => {
                    if(this.ctx.state === 'suspended') {
                        this.ctx.resume();
                        // Try to play a silent sound to unlock audio on iOS/Safari
                        const buffer = this.ctx.createBuffer(1, 1, 22050);
                        const source = this.ctx.createBufferSource();
                        source.buffer = buffer;
                        source.connect(this.ctx.destination);
                        source.start(0);
                        this.unlocked = true;
                    }
                    ['click', 'touchstart', 'keydown'].forEach(e => document.removeEventListener(e, unlockAudio));
                };
                ['click', 'touchstart', 'keydown'].forEach(e => document.addEventListener(e, unlockAudio));
            }

            setMasterVolume(val) {
                this.masterVolume = parseFloat(val);
                this.applyVolumes();
            }

            setCommentaryVolume(val) {
                this.commentaryVolume = parseFloat(val);
                this.applyVolumes();
            }

            setCrowdVolume(val) {
                this.crowdVolume = parseFloat(val);
                this.applyVolumes();
            }

            applyVolumes() {
                // Apply to gameplay sounds
                this.gameplayCategories.forEach(category => {
                    if (this.sounds[category]) {
                        this.sounds[category].forEach(s => s.volume = this.masterVolume);
                    }
                });

                // Apply to commentary sounds
                this.commentaryCategories.forEach(category => {
                    if (this.sounds[category]) {
                        this.sounds[category].forEach(s => s.volume = this.masterVolume * this.commentaryVolume);
                    }
                });

                // Apply to crowd loop
                if (this.crowdLoop) {
                    this.crowdLoop.volume = this.masterVolume * this.crowdVolume * 0.3; // Crowd is background, so quieter
                }
            }

            stopAllSounds(exceptCategory = null) {
                for (const category in this.sounds) {
                    if (this.sounds.hasOwnProperty(category) && category !== exceptCategory) {
                        this.sounds[category].forEach(sound => {
                            if (!sound.paused) {
                                sound.pause();
                                sound.currentTime = 0;
                            }
                        });
                    }
                }
            }

            isCommentary(category) {
                return this.commentaryCategories.includes(category);
            }

            isGameplay(category) {
                return this.gameplayCategories.includes(category);
            }

            playSound(category) {
                // On win, stop all other sounds to give it priority
                if (category === 'win') {
                    this.stopAllSounds('win');
                }

                if(this.sounds[category] && this.sounds[category].length > 0) {
                    const files = this.sounds[category];
                    const sound = files[Math.floor(Math.random() * files.length)];
                    sound.currentTime = 0;
                    
                    if (this.isCommentary(category)) {
                        sound.volume = this.masterVolume * this.commentaryVolume;
                    } else { // Gameplay sounds
                        sound.volume = this.masterVolume;
                    }
                    
                    sound.play().catch(e => console.warn("Audio play failed:", e));
                }
            }

            playCrowdLoop() {
                if (this.crowdLoop) {
                    this.crowdLoop.currentTime = 0;
                    this.crowdLoop.volume = this.masterVolume * this.crowdVolume * 0.3; // Set initial volume
                    this.crowdLoop.play().catch(e => console.warn("Crowd audio loop failed to play:", e));
                }
            }

            stopCrowdLoop() {
                if (this.crowdLoop) {
                    this.crowdLoop.pause();
                }
            }

            playBatHit() {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(1 * this.masterVolume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            }

            playCheer() {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                // Simple crowd cheer simulation using multiple oscillators
                for(let i=0; i<5; i++) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.frequency.value = 200 + Math.random() * 400;
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(0.05 * this.masterVolume, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1.5);
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 1.5);
                }
            }
        }

        // --- SYSTEM: Texture Generator ---
        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#2e8b57'; ctx.fillRect(0,0,512,512);
            for(let i=0; i<40000; i++) {
                ctx.fillStyle = Math.random()>0.5 ? '#3cb371' : '#228b22';
                ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
            }
            return new THREE.CanvasTexture(canvas);
        }

        // --- SYSTEM: Auction Logic ---
        class AuctionSystem {
            constructor() {
                this.currentPlayerIndex = 0;
                this.currentBid = 0;
                this.currentHolder = null;
                this.userBudget = 120.0;
                this.userSquadCount = 0;
                this.isBiddingActive = false;
                this.timer = null;
                this.userTeamId = 'MI'; // Default
                this.mySquad = [];
                this.isAuctionComplete = false;
            }

            start() {
                this.currentPlayerIndex = 0;
                this.userSquadCount = 0;
                gameApp.game3D.createAuctionTables(); // Show tables
                document.getElementById('auction-squad-list').innerHTML = ''; // Clear sidebar
                this.loadPlayer(this.currentPlayerIndex);
            }

            loadPlayer(index) {
                if (index >= PLAYERS_2025.length || this.userSquadCount >= 25) {
                    alert("Auction Completed! Starting Tournament...");
                    gameApp.startTournament();
                    return;
                }

                const player = PLAYERS_2025[index];
                this.currentBid = player.base;
                this.currentHolder = null;
                this.isBiddingActive = true;

                document.getElementById('auc-player-name').innerText = player.name;
                document.getElementById('auc-player-role').innerText = player.role;
                document.getElementById('auc-base-price').innerText = player.base + " Cr";
                document.getElementById('auc-current-bid').innerText = this.currentBid.toFixed(2) + " Cr";
                document.getElementById('auc-current-holder').innerText = "Unsold";
                document.getElementById('squad-count').innerText = this.userSquadCount;
                document.getElementById('auc-log').innerHTML = "<div>Bidding started for " + player.name + "</div>";
                gameApp.game3D.showPlayerOnStage(player);

                this.aiBiddingLoop();
            }

            placeBid() {
                if (!this.isBiddingActive) return;
                if (this.userBudget < this.currentBid + 0.25) {
                    alert("Insufficient Budget!");
                    return;
                }

                this.currentBid += 0.25;
                this.currentHolder = `YOU (${this.userTeamId})`;
                this.updateUI();
                this.logBid(`YOU (${this.userTeamId})`, this.currentBid);

                // Reset AI timer to keep the flow smooth
                this.aiBiddingLoop();
            }

            aiBiddingLoop() {
                if (this.timer) clearTimeout(this.timer);

                this.timer = setTimeout(() => {
                    if (!this.isBiddingActive) return;

                    // AI Logic: Random chance to bid
                    const shouldBid = Math.random() > 0.5;
                    
                    if (shouldBid && this.currentBid < 15.0) { // Cap at 15Cr for demo
                        const availableTeams = TEAMS.filter(t => t.id !== this.userTeamId);
                        const randomTeam = availableTeams[Math.floor(Math.random() * availableTeams.length)];

                        this.currentBid += 0.25;
                        this.currentHolder = randomTeam.name;
                        this.logBid(randomTeam.id, this.currentBid);
                        this.updateUI();
                        this.aiBiddingLoop(); // Continue loop
                    } else {
                        // AI stops bidding, sell to current holder
                        this.sold();
                    }
                }, 2000);
            }

            logBid(who, amount) {
                const log = document.getElementById('auc-log');
                const entry = document.createElement('div');
                entry.innerText = `${who} bids ${amount.toFixed(2)} Cr`;
                entry.style.color = who.includes("YOU") ? "#4caf50" : "#fff";
                log.prepend(entry);
            }

            updateUI() {
                document.getElementById('auc-current-bid').innerText = this.currentBid.toFixed(2) + " Cr";
                document.getElementById('auc-current-holder').innerText = this.currentHolder;
            }

            sold() {
                this.isBiddingActive = false;
                const log = document.getElementById('auc-log');
                const entry = document.createElement('div');
                
                if (this.currentHolder) {
                    entry.innerText = `SOLD to ${this.currentHolder} for ${this.currentBid.toFixed(2)} Cr!`;
                    entry.style.color = "gold";
                    entry.style.fontWeight = "bold";
                    
                    if (this.currentHolder.includes("YOU")) {
                        try {
                            this.userBudget -= this.currentBid;
                            this.userSquadCount++;
                            document.getElementById('user-budget').innerText = this.userBudget.toFixed(2) + " Cr";
                            document.getElementById('squad-count').innerText = this.userSquadCount;
                            const player = PLAYERS_2025[this.currentPlayerIndex];
                            this.mySquad.push({
                                name: player.name,
                                role: player.role,
                                price: Number(this.currentBid),
                                jerseyNumber: player.jerseyNumber,
                                power: player.power,
                                timing: player.timing
                            });
                            this.updateSidebar();
                            gameApp.saveCareer(); // Save after buy
                        } catch(e) {
                            console.error("Error processing buy:", e);
                        }
                    }
                } else {
                    entry.innerText = `UNSOLD`;
                    entry.style.color = "red";
                }
                log.prepend(entry);

                setTimeout(() => {
                    gameApp.saveCareer(); // Save state (index update)
                    this.currentPlayerIndex++;
                    this.loadPlayer(this.currentPlayerIndex);
                }, 3000);
            }

            updateSidebar() {
                const list = document.getElementById('auction-squad-list');
                if (!list) return;
                list.innerHTML = ''; // Clear the list to rebuild

                const categorizedSquad = {
                    'Batters': [],
                    'Bowlers': [],
                    'All-Rounders': [],
                    'Wicketkeeper Batters': []
                };

                // Group players from mySquad into categories
                this.mySquad.forEach(player => {
                    if (player.role === 'Batter') categorizedSquad['Batters'].push(player);
                    else if (player.role === 'Bowler') categorizedSquad['Bowlers'].push(player);
                    else if (player.role === 'All-Rounder') categorizedSquad['All-Rounders'].push(player);
                    else if (player.role === 'Wicketkeeper Batter') categorizedSquad['Wicketkeeper Batters'].push(player);
                });

                // Define the order to display categories
                const categoryOrder = ['Batters', 'Bowlers', 'All-Rounders', 'Wicketkeeper Batters'];

                // Generate and append HTML for each category
                categoryOrder.forEach(categoryName => {
                    const players = categorizedSquad[categoryName];
                    
                    const categoryContainer = document.createElement('div');
                    categoryContainer.style.marginBottom = '15px';

                    // Create and append the header (e.g., "Batters (3)")
                    const header = document.createElement('h4');
                    header.style.color = 'gold';
                    header.style.margin = '0 0 5px 0';
                    header.style.borderBottom = '1px solid #555';
                    header.style.paddingBottom = '5px';
                    header.innerText = `${categoryName} (${players.length})`;
                    categoryContainer.appendChild(header);

                    // Create and append the list of players for the category
                    players.forEach(p => {
                        const item = document.createElement('div');
                        item.className = 'squad-item'; // Use existing class for styling
                        item.innerHTML = `<span>${p.name}</span><span style="color:#4caf50">${Number(p.price).toFixed(2)} Cr</span>`;
                        categoryContainer.appendChild(item);
                    });

                    list.appendChild(categoryContainer);
                });
            }

            skipPlayer() {
                if(this.isBiddingActive) {
                    this.isBiddingActive = false;
                    this.currentPlayerIndex++;
                    this.loadPlayer(this.currentPlayerIndex);
                }
            }

            autoFillSquad() {
                this.isBiddingActive = false;
                alert("Simulating remaining auction... Squad filled!");
                this.isAuctionComplete = true;
                gameApp.startTournament();
            }

            finishAuction() {
                this.isBiddingActive = false;
                this.isAuctionComplete = true;
                gameApp.startTournament();
            }

            showSquad() {
                gameApp.showScreen('squad-screen');
                const tbody = document.getElementById('squad-body');
                tbody.innerHTML = '';
                this.mySquad.forEach(p => {
                    tbody.innerHTML += `<tr><td>${p.name}</td><td>${p.role}</td><td>Pow: ${p.power} | Tim: ${p.timing}</td><td>${p.price.toFixed(2)} Cr</td></tr>`;
                });
            }
        }

        // --- SYSTEM: 3D Graphics (Three.js) ---
        class Game3D {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); // Sky Blue
                this.scene.fog = new THREE.Fog(0x87CEEB, 100, 500); // Fog for depth
                this.stadiumModel = null;
                this.animationState = null; // Can be 'intro', 'countdown', 'match'
                this.introAnimationTime = 0;
                this.onIntroComplete = null;
                this.mixers = [];
                this.clock = new THREE.Clock();

                // Game Objects
                this.ball = null;
                this.batsmanGroup = null;
                this.bowlerGroup = null;
                this.nonStrikerGroup = null;
                this.umpire = null;
                this.auctionTables = [];
                this.fielders = [];
                this.particles = [];
                this.lights = [];
                this.confetti = [];
                this.shakeIntensity = 0;
                this.fireworks = [];
                this.targets = [];
                
                // Ball Trail
                this.trailPositions = new Float32Array(600); // 200 points
                this.trailGeometry = new THREE.BufferGeometry();
                this.trailGeometry.setAttribute('position', new THREE.BufferAttribute(this.trailPositions, 3));
                this.trailLine = new THREE.Line(this.trailGeometry, new THREE.LineBasicMaterial({ color: 0xffff00, opacity: 0.6, transparent: true }));
                this.trailLine.frustumCulled = false;
                this.scene.add(this.trailLine);
                this.trailIdx = 0;

                // Pitch Marker
                this.pitchMarker = new THREE.Mesh(new THREE.RingGeometry(0.2, 0.3, 32), new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide }));
                this.pitchMarker.rotation.x = -Math.PI / 2;
                this.pitchMarker.visible = false;
                this.scene.add(this.pitchMarker);

                // Pre-load ball model
                this.ball = new THREE.Group();
                new THREE.GLTFLoader().load('cricket_ball.glb', (gltf) => {
                    const ballModel = gltf.scene;
                    ballModel.scale.set(0.08, 0.08, 0.08); // Scale to correct size
                    this.ball.add(ballModel);
                }, undefined, (error) => {
                    console.error("Ball model cricket_ball.glb not loaded, using sphere.", error);
                    const ballGeo = new THREE.SphereGeometry(0.08, 16, 16);
                    this.ball.add(new THREE.Mesh(ballGeo, ballMat));
                });
                this.ball.visible = false;
                this.scene.add(this.ball);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                this.introCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 2000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                // This new check handles cases where WebGL context creation fails.
                // It prevents the game from crashing and shows a user-friendly error message.
                if (!this.renderer.getContext()) {
                    const errorMsg = 'Your browser or device does not support WebGL, which is required to play this game. Please try a different browser like Chrome or Firefox, or check your browser settings to ensure WebGL is enabled.';
                    const container = document.getElementById('game-container');
                    if (container) container.innerHTML = `<div style="padding: 20px; color: white; text-align: center; font-size: 1.5rem;"><h1>Fatal Error</h1><p>${errorMsg}</p></div>`;
                    const ui = document.getElementById('ui-layer');
                    if (ui) ui.style.display = 'none'; // Hide game UI
                    throw new Error("WebGL context not available."); // Stop further script execution
                }
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer, realistic shadows
                document.getElementById('game-container').appendChild(this.renderer.domElement);

                // Lighting
                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                this.scene.add(this.ambientLight);

                // Hemisphere Light for better outdoor look
                this.hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
                this.scene.add(this.hemiLight);
                
                this.dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                this.dirLight.position.set(50, 100, 50);
                this.dirLight.castShadow = true;
                // Adjust shadow camera frustum for large stadium
                this.dirLight.shadow.mapSize.width = 2048;
                this.dirLight.shadow.mapSize.height = 2048;
                this.dirLight.shadow.camera.top = 100;
                this.dirLight.shadow.camera.bottom = -100;
                this.dirLight.shadow.camera.left = -100;
                this.dirLight.shadow.camera.right = 100;
                this.scene.add(this.dirLight);

                this.createStadium();
                this.createPitch();
                this.createWickets();
                this.createFloodlights();
                
                // Camera Position (Behind Bowler view)
                this.camera.position.set(0, 5, 10);
                this.camera.lookAt(0, 0, -3);

                // Animation Loop
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);

                // Resize Handler
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            setDayNightMode(isNight) {
                if(isNight) {
                    this.scene.background = new THREE.Color(0x050510);
                    this.scene.fog = new THREE.Fog(0x050510, 100, 500);
                    this.ambientLight.intensity = 0.2;
                    this.hemiLight.intensity = 0.2;
                    this.dirLight.intensity = 0.1; // Moon/Floodlight main
                    this.lights.forEach(l => l.intensity = 1.5); // Turn on floodlights
                } else {
                    this.scene.background = new THREE.Color(0x87CEEB);
                    this.scene.fog = new THREE.Fog(0x87CEEB, 100, 500);
                    this.ambientLight.intensity = 0.6;
                    this.hemiLight.intensity = 0.6;
                    this.dirLight.intensity = 1.0; // Sun
                    this.lights.forEach(l => l.intensity = 0); // Turn off floodlights
                }
            }

            createFloodlights() {
                const positions = [[-60, 40, -60], [60, 40, -60], [-60, 40, 60], [60, 40, 60]];
                positions.forEach(pos => {
                    const pole = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 40), new THREE.MeshStandardMaterial({color: 0x555555}));
                    pole.position.set(pos[0], 20, pos[2]);
                    this.scene.add(pole);
                    const light = new THREE.PointLight(0xffffff, 0, 200); // Start off
                    light.position.set(pos[0], 40, pos[2]);
                    this.scene.add(light);
                    this.lights.push(light);
                });
            }

            createStadium() {
                // Procedurally generate the ground
                const groundTex = createGrassTexture();
                groundTex.wrapS = THREE.RepeatWrapping;
                groundTex.wrapT = THREE.RepeatWrapping;
                groundTex.repeat.set(16, 16);
                const groundGeo = new THREE.CircleGeometry(100, 64); // A large circular ground
                const groundMat = new THREE.MeshStandardMaterial({ map: groundTex, roughness: 0.9 });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = 0;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // Add crowd to represent the stadium stands
                this.createCrowd();
            }

            createCrowd() {
                const crowdCount = 1500;
                const crowdGeo = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                const colorPalette = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xffffff, 0xffa500, 0x00ffff];

                for(let i=0; i<crowdCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 80 + Math.random() * 4; 
                    const y = 5 + Math.random() * 8;
                    positions.push(Math.cos(angle)*radius, y, Math.sin(angle)*radius);
                    const color = new THREE.Color(colorPalette[Math.floor(Math.random() * colorPalette.length)]);
                    colors.push(color.r, color.g, color.b);
                }
                crowdGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                crowdGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                this.scene.add(new THREE.Points(crowdGeo, new THREE.PointsMaterial({ size: 1.2, vertexColors: true })));
            }

            createPitch() {
                const geometry = new THREE.PlaneGeometry(3, 22);
                const material = new THREE.MeshStandardMaterial({ color: 0xe1c699 }); // Dirt color
                const pitch = new THREE.Mesh(geometry, material);
                pitch.rotation.x = -Math.PI / 2;
                pitch.position.y = 0.01; // Slightly above grass
                pitch.receiveShadow = true;
                this.scene.add(pitch);

                // Crease Lines (White)
                const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const redLineMat = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red for popping crease
                
                // Popping Crease (Batsman End)
                const popBat = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 0.1), redLineMat); // Using red material
                popBat.rotation.x = -Math.PI / 2;
                popBat.position.set(0, 0.02, -9.8); // 1.22m from stumps (-11)
                this.scene.add(popBat);

                // Popping Crease (Bowler End)
                const popBowl = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 0.1), redLineMat); // Using red material
                popBowl.rotation.x = -Math.PI / 2;
                popBowl.position.set(0, 0.02, 9.8);
                this.scene.add(popBowl);

                // Wide/Return Crease Lines (Sides) - Now Black
                const blackLineMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const wideL = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 22), blackLineMat); wideL.rotation.x = -Math.PI/2; wideL.position.set(-1.3, 0.02, 0); this.scene.add(wideL);
                const wideR = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 22), blackLineMat); wideR.rotation.x = -Math.PI/2; wideR.position.set(1.3, 0.02, 0); this.scene.add(wideR);
            }

            celebrate50() {
                const batsman = this.batsmanGroup;
                let jumpHeight = 0;
                const jumpInterval = setInterval(() => {
                    jumpHeight += 0.2;
                    batsman.position.y = Math.sin(jumpHeight) * 0.5;
                    if(jumpHeight > Math.PI) {
                        clearInterval(jumpInterval);
                        batsman.position.y = 0;
                    }
                }, 50);
            }

            createAuctionTables() {
                // Create 10 tables in a semi-circle
                const radius = 15;
                for(let i=0; i<10; i++) {
                    const angle = (i / 9) * Math.PI; // 0 to PI
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    const tableGeo = new THREE.BoxGeometry(2, 1, 1);
                    const tableMat = new THREE.MeshStandardMaterial({ color: TEAMS[i].color });
                    const table = new THREE.Mesh(tableGeo, tableMat);
                    table.position.set(x, 0.5, z);
                    table.lookAt(0, 0, 0);
                    this.scene.add(table);
                    this.auctionTables.push(table);
                }
            }

            createWickets() {
                const stumpGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.71, 8); // Scaled to realistic stump diameter
                const stumpMat = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red for visibility
                const bailGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.15, 8);
                
                // Bowler's end
                for(let i=-1; i<=1; i++) {
                    const stump = new THREE.Mesh(stumpGeo, stumpMat);
                    stump.position.set(i*0.11, 0.355, 11); // Adjusted spacing and height for realism
                    stump.castShadow = true;
                    this.scene.add(stump);
                }
                // Bails Bowler End
                for(let i=0; i<2; i++) {
                    const bail = new THREE.Mesh(bailGeo, stumpMat);
                    bail.rotation.z = Math.PI / 2;
                    bail.position.set(i === 0 ? -0.055 : 0.055, 0.71, 11); // Adjusted for new stump spacing
                    this.scene.add(bail);
                }

                // Batsman's end
                for(let i=-1; i<=1; i++) {
                    const stump = new THREE.Mesh(stumpGeo, stumpMat);
                    stump.position.set(i*0.11, 0.355, -11); // Adjusted spacing and height for realism
                    stump.castShadow = true;
                    this.scene.add(stump);
                }
                // Bails Batsman End
                for(let i=0; i<2; i++) {
                    const bail = new THREE.Mesh(bailGeo, stumpMat);
                    bail.rotation.z = Math.PI / 2;
                    bail.position.set(i === 0 ? -0.055 : 0.055, 0.71, -11); // Adjusted for new stump spacing
                    this.scene.add(bail);
                }
            }

            createProceduralPlayerModel(player, team, isBatsman = false) {
                const group = new THREE.Group();
                
                // --- Materials (more realistic with roughness) ---
                const skinMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
                const hairMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.6 });
                const shoeMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5 });
                const defaultTeamColorMat = new THREE.MeshStandardMaterial({ color: team.color, roughness: 0.8 });
                
                // --- Jersey & Trousers Materials ---
                // Pant Material
                const defaultPantMat = new THREE.MeshStandardMaterial({ color: 0xf0f0f0, roughness: 0.9 });
                const pantMat = defaultPantMat.clone();

                // Back Material with Canvas for Name/Number
                const backMat = defaultTeamColorMat.clone(); // Start with team color
                if (player && player.name && player.jerseyNumber) {
                    const backCanvas = document.createElement('canvas');
                    const backCtx = backCanvas.getContext('2d');
                    backCanvas.width = 256;
                    backCanvas.height = 256;

                    // Fill with team color
                    backCtx.fillStyle = '#' + new THREE.Color(team.color).getHexString();
                    backCtx.fillRect(0, 0, backCanvas.width, backCanvas.height);

                    // Draw Name (last name)
                    const lastName = player.name.split(' ').pop().toUpperCase();
                    backCtx.font = 'bold 48px Arial'; // Increased font size for visibility
                    backCtx.fillStyle = 'white';
                    backCtx.textAlign = 'center';
                    backCtx.strokeStyle = 'black';
                    backCtx.lineWidth = 5; // Thicker outline for better contrast
                    backCtx.strokeText(lastName, backCanvas.width / 2, backCanvas.height * 0.4);
                    backCtx.fillText(lastName, backCanvas.width / 2, backCanvas.height * 0.4);

                    // Draw Number
                    backCtx.font = 'bold 110px Arial'; // Increased font size
                    backCtx.strokeText(player.jerseyNumber, backCanvas.width / 2, backCanvas.height * 0.8); // Adjusted position
                    backCtx.fillText(player.jerseyNumber, backCanvas.width / 2, backCanvas.height * 0.8); // Adjusted position

                    backMat.map = new THREE.CanvasTexture(backCanvas);
                    backMat.needsUpdate = true;
                }

                const bodyMaterials = [
                    defaultTeamColorMat, // right
                    defaultTeamColorMat, // left
                    defaultTeamColorMat, // top
                    defaultTeamColorMat, // bottom
                    defaultTeamColorMat, // front
                    backMat              // back
                ];

                // --- Body Parts (Improved Shapes & Proportions) ---
                // Head (Slightly Oval)
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), skinMat);
                head.scale.y = 1.1; head.position.y = 1.65;
                group.add(head);

                // Neck
                const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.1), skinMat);
                neck.position.y = 1.5; group.add(neck);

                // Hair/Helmet
                const helmet = new THREE.Mesh(new THREE.SphereGeometry(0.22, 16, 16), isBatsman ? new THREE.MeshStandardMaterial({color: 0x000044, metalness: 0.3, roughness: 0.4}) : hairMat);
                helmet.position.y = 1.7; if(isBatsman) group.add(helmet);

                // Body (Box for a more defined torso)
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.7, 0.25), bodyMaterials);
                body.position.y = 1.1; group.add(body);

                // Arms
                const armGeo = new THREE.CylinderGeometry(0.07, 0.06, 0.65);
                const armL = new THREE.Mesh(armGeo, skinMat);
                armL.position.set(-0.28, 1.3, 0);
                armL.name = "arm_left"; group.add(armL);
                
                const armR = new THREE.Mesh(armGeo, skinMat);
                armR.position.set(0.28, 1.3, 0);
                armR.name = "arm_right"; group.add(armR);

                // Legs
                const legGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.8);
                const legL = new THREE.Mesh(legGeo, pantMat);
                legL.position.set(-0.12, 0.4, 0); group.add(legL);

                const legR = new THREE.Mesh(legGeo, pantMat);
                legR.position.set(0.12, 0.4, 0); group.add(legR);

                // Feet
                const footGeo = new THREE.BoxGeometry(0.15, 0.08, 0.25);
                const footL = new THREE.Mesh(footGeo, shoeMat);
                footL.position.set(-0.12, 0.04, 0.05); group.add(footL);

                const footR = new THREE.Mesh(footGeo, shoeMat);
                footR.position.set(0.12, 0.04, 0.05); group.add(footR);
                
                if(isBatsman) {
                    // Pads (Leg Guards)
                    const padGeo = new THREE.CylinderGeometry(0.12, 0.1, 0.5);
                    const padMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6 });
                    const padL = new THREE.Mesh(padGeo, padMat); padL.position.set(-0.12, 0.3, 0.08); group.add(padL);
                    const padR = new THREE.Mesh(padGeo, padMat); padR.position.set(0.12, 0.3, 0.08); group.add(padR);
                }

                // Bat
                if (isBatsman) {
                    // Batsman ready stance: arms forward to hold bat, not open
                    armL.rotation.set(0.6, 0, 0.5);
                    armR.rotation.set(0.6, 0, -0.5);

                    const handedness = player.handedness || 'right';
                    group.userData.handedness = handedness; // Store for animation access

                    const batGeo = new THREE.BoxGeometry(0.15, 0.8, 0.05);
                    const batMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.5 });
                    const bat = new THREE.Mesh(batGeo, batMat);

                    if (handedness === 'left') {
                        bat.position.set(-0.4, 0.6, 0.2);
                        bat.rotation.z = 0.5;
                        bat.rotation.x = 0.5;
                        group.rotation.y = -0.2; // Stance adjustment
                    } else {
                        bat.position.set(0.4, 0.6, 0.2);
                        bat.rotation.z = -0.5;
                        bat.rotation.x = 0.5;
                        group.rotation.y = 0.2; // Stance adjustment
                    }

                    group.add(bat);
                    group.userData.bat = bat; // Store in group data

                    // Gloves
                    const gloveGeo = new THREE.SphereGeometry(0.09);
                    const gloveMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7 });
                    const gloveL = new THREE.Mesh(gloveGeo, gloveMat); gloveL.position.set(-0.35, 1.0, 0.1); group.add(gloveL);
                    const gloveR = new THREE.Mesh(gloveGeo, gloveMat); gloveR.position.set(0.35, 1.0, 0.1); group.add(gloveR);
                } else {
                    // Fielder ready stance: arms down and slightly forward, not wide open like a T-pose.
                    armL.rotation.set(0.4, 0, 0.15);
                    armR.rotation.set(0.4, 0, -0.15);

                    // Simulate a slight knee bend for a more athletic fielding stance by lowering the upper body.
                    body.position.y -= 0.1;
                    head.position.y -= 0.1;
                    neck.position.y -= 0.1;
                    armL.position.y -= 0.1;
                    armR.position.y -= 0.1;
                }

                return group;
            }

            createUmpireModel() {
                const group = new THREE.Group();
                
                // Materials
                const whiteMat = new THREE.MeshStandardMaterial({ color: 0xf5f5f5, roughness: 0.8 });
                const blackMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 }); // Black for trousers
                const skinMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });

                // Head
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16), skinMat);
                head.position.y = 1.65;
                group.add(head);

                // Hat
                const hat = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.1), whiteMat);
                hat.position.y = 1.8;
                group.add(hat);
                const hatBrim = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.05), whiteMat);
                hatBrim.position.y = 1.75;
                group.add(hatBrim);

                // Body (white coat)
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.7, 0.25), whiteMat);
                body.position.y = 1.1;
                group.add(body);

                // Arms
                const armGeo = new THREE.CylinderGeometry(0.07, 0.06, 0.65);
                const armL = new THREE.Mesh(armGeo, skinMat);
                armL.position.set(-0.28, 1.3, 0);
                group.add(armL);
                
                const armR = new THREE.Mesh(armGeo, skinMat);
                armR.position.set(0.28, 1.3, 0);
                group.add(armR);

                // Legs (black trousers)
                const legGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.8);
                const legL = new THREE.Mesh(legGeo, blackMat);
                legL.position.set(-0.12, 0.4, 0);
                group.add(legL);

                const legR = new THREE.Mesh(legGeo, blackMat);
                legR.position.set(0.12, 0.4, 0);
                group.add(legR);

                // Feet (black shoes)
                const footGeo = new THREE.BoxGeometry(0.15, 0.08, 0.25);
                const footL = new THREE.Mesh(footGeo, blackMat);
                footL.position.set(-0.12, 0.04, 0.05);
                group.add(footL);

                const footR = new THREE.Mesh(footGeo, blackMat);
                footR.position.set(0.12, 0.04, 0.05);
                group.add(footR);

                return group;
            }

            createPlayerModel(player, team, isBatsman = false) {
                return this.createProceduralPlayerModel(player, team, isBatsman);
            }

            showPlayerOnStage(player) {
                // Clear previous dynamic objects
                if(this.displayPlayer) this.scene.remove(this.displayPlayer);
                
                // Find a default team for display purposes, e.g., the user's team
                const displayTeam = TEAMS.find(t => t.id === window.auctionSystem.userTeamId) || TEAMS[0];
                
                this.displayPlayer = this.createPlayerModel(player, displayTeam, false);
                this.displayPlayer.position.set(0, 0, 0);
                this.displayPlayer.scale.set(2.0, 2.0, 2.0);
                this.scene.add(this.displayPlayer);
            }

            launchFireworks() {
                const color = new THREE.Color().setHSL(Math.random(), 1, 0.5);
                const x = (Math.random() - 0.5) * 60;
                const z = -30 - Math.random() * 20;
                const y = 30 + Math.random() * 10;
                
                const particleGeo = new THREE.BufferGeometry();
                const count = 100;
                const positions = [];
                const velocities = [];
                
                for(let i=0; i<count; i++) {
                    positions.push(x, y, z);
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const speed = 0.5 + Math.random() * 0.5;
                    velocities.push({
                        x: speed * Math.sin(phi) * Math.cos(theta),
                        y: speed * Math.cos(phi),
                        z: speed * Math.sin(phi) * Math.sin(theta)
                    });
                }
                
                particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({ color: color, size: 0.8, transparent: true });
                const system = new THREE.Points(particleGeo, material);
                system.userData = { velocities: velocities, life: 1.0 };
                this.scene.add(system);
                this.fireworks.push(system);
            }

            resetTrail() {
                this.trailIdx = 0;
                this.trailPositions.fill(0);
                this.trailGeometry.attributes.position.needsUpdate = true;
                this.trailLine.visible = false;
            }

            updateTrail(pos) {
                if(this.trailIdx >= 600) return; // Limit
                this.trailPositions[this.trailIdx++] = pos.x;
                this.trailPositions[this.trailIdx++] = pos.y;
                this.trailPositions[this.trailIdx++] = pos.z;
                this.trailGeometry.setDrawRange(0, this.trailIdx / 3);
                this.trailGeometry.attributes.position.needsUpdate = true;
                this.trailLine.visible = true;
            }

            setupMatchScene() {
                // Clear auction player
                if(this.displayPlayer) this.scene.remove(this.displayPlayer);
                // Clear tables
                this.auctionTables.forEach(t => this.scene.remove(t));
                this.auctionTables = [];
                // Clear fielders
                if(this.fielders) this.fielders.forEach(f => this.scene.remove(f));
                this.fielders = [];
                // Clear non-striker
                if(this.nonStrikerGroup) this.scene.remove(this.nonStrikerGroup);
                // Clear umpire
                if(this.umpire) this.scene.remove(this.umpire);

                // Determine Colors based on Role
                const userTeamObj = TEAMS.find(t => t.id === gameApp.userTeamId);
                const oppTeamObj = gameApp.currentOpponent;

                const isUserBatting = gameApp.playerRole === 'batting';
                const battingTeamObj = isUserBatting ? userTeamObj : oppTeamObj;
                const fieldingTeamObj = isUserBatting ? oppTeamObj : userTeamObj;

                // Ensure players are defined, use dummy if not (shouldn't happen in normal flow)
                const currentBatsman = gameApp.currentBatsman || { name: "Batsman", jerseyNumber: 1, role: "Batter" };
                const currentNonStriker = gameApp.currentNonStriker || { name: "Non-Striker", jerseyNumber: 2, role: "Batter" };
                const currentBowler = gameApp.currentBowler || { name: "Bowler", jerseyNumber: 3, role: "Bowler" };

                // Add Batsman
                if (this.batsmanGroup) this.scene.remove(this.batsmanGroup);
                this.batsmanGroup = this.createPlayerModel(currentBatsman, battingTeamObj, true); 
                this.batsmanGroup.position.set(0, 0, -10);
                this.scene.add(this.batsmanGroup);

                // Add Non-Striker
                if (this.nonStrikerGroup) this.scene.remove(this.nonStrikerGroup);
                this.nonStrikerGroup = this.createPlayerModel(currentNonStriker, battingTeamObj, true);
                this.nonStrikerGroup.position.set(-2, 0, 8); // Near bowler end
                this.nonStrikerGroup.rotation.y = Math.PI; // Facing striker
                this.scene.add(this.nonStrikerGroup);

                // Add Bowler
                if (this.bowlerGroup) this.scene.remove(this.bowlerGroup);
                this.bowlerGroup = this.createPlayerModel(currentBowler, fieldingTeamObj, false); 
                this.bowlerGroup.position.set(0, 0, 10);
                this.scene.add(this.bowlerGroup);

                // Add Fielders (Opponent Team)
                const formationName = window.gameApp ? window.gameApp.currentFormation : 'Default';
                const fPos = FIELD_PLACEMENTS[formationName];

                fPos.forEach(p => {
                    const dummyFielder = { name: 'Fielder', jerseyNumber: Math.floor(Math.random() * 99) + 1 };
                    const f = this.createPlayerModel(dummyFielder, fieldingTeamObj, false);
                    f.position.set(p.x, 0, p.z);
                    f.userData.originalPosition = f.position.clone();
                    f.lookAt(0, 0, -10);
                    this.scene.add(f);
                    this.fielders.push(f);
                });

                // Add Umpire
                this.umpire = this.createUmpireModel();
                this.umpire.position.set(0, 0, 15); // Behind bowler's end
                this.umpire.lookAt(0, 0, -10); // Look towards batsman
                this.scene.add(this.umpire);
            }

            triggerShake(intensity) {
                this.shakeIntensity = intensity;
            }

            createExplosion(position) {
                const particleGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const particleMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
                
                for(let i=0; i<20; i++) {
                    const mesh = new THREE.Mesh(particleGeo, particleMat);
                    mesh.position.copy(position);
                    mesh.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        Math.random() * 0.5,
                        (Math.random() - 0.5) * 0.5
                    );
                    this.scene.add(mesh);
                    this.particles.push(mesh);
                }
            }

            updateFielders(ballPosition, ballVelocity, isAerial) {
                if(!this.fielders.length || !window.gameApp || !window.gameApp.ballActive || !window.gameApp.shotPlayed) return;
                
                // Find closest fielder
                let closest = null;
                let minDst = 1000;
                
                this.fielders.forEach(f => {
                    if (f.userData.isAnimating) return; // Skip players in an animation
                    const d = f.position.distanceTo(ballPosition);
                    if(d < minDst) { minDst = d; closest = f; }
                });
                
                if(closest && minDst > 1.5 && minDst < 60) { // Fielder's effective range
                    let targetPosition = ballPosition.clone();
                    if (isAerial) {
                        targetPosition.y = 0; // Fielder runs on the ground.
                    } else {
                        const behindVector = ballVelocity.clone().normalize().multiplyScalar(-5); // Target 5 units behind the ball
                        targetPosition.add(behindVector);
                    }
                    const dir = new THREE.Vector3().subVectors(targetPosition, closest.position).normalize();
                    dir.y = 0; // Fielders don't fly
                    closest.position.add(dir.multiplyScalar(0.25)); // Fielder run speed
                    closest.lookAt(ballPosition);
                    closest.position.y = Math.abs(Math.sin(Date.now() * 0.02)) * 0.3;
                }
            }

            triggerFielderAnimation(fielder, type, targetPosition) {
                if (!fielder || fielder.userData.isAnimating) return;

                fielder.userData.isAnimating = true;
                // Stop any existing running animation
                fielder.position.y = 0;

                if (type === 'catch') {
                    const originalY = fielder.position.y;
                    const armL = fielder.getObjectByName("arm_left");
                    const armR = fielder.getObjectByName("arm_right");
                    const originalRotL = armL ? armL.rotation.clone() : null;
                    const originalRotR = armR ? armR.rotation.clone() : null;

                    let jumpHeight = 0;
                    const jumpInterval = setInterval(() => {
                        jumpHeight += 0.2;
                        fielder.position.y = originalY + Math.sin(jumpHeight) * 0.6; // Jump up
                        if (armL) armL.rotation.x = -Math.PI / 2; // Raise arms
                        if (armR) armR.rotation.x = -Math.PI / 2;

                        if (jumpHeight > Math.PI) {
                            clearInterval(jumpInterval);
                            fielder.position.y = originalY;
                            if (armL && originalRotL) armL.rotation.copy(originalRotL); // Restore arm rotation
                            if (armR && originalRotR) armR.rotation.copy(originalRotR);
                            fielder.userData.isAnimating = false;
                        }
                    }, 30);

                } else if (type === 'dive') {
                    const originalPos = fielder.position.clone();
                    const originalRot = fielder.rotation.clone();

                    // Look towards the dive target
                    fielder.lookAt(targetPosition);
                    
                    let diveProgress = 0;
                    const diveInterval = setInterval(() => {
                        diveProgress += 0.1;

                        // Animate rotation forward and then back up
                        const diveAngle = Math.sin(diveProgress * Math.PI) * (Math.PI / 2.5); // Goes up to 72 degrees and back
                        fielder.rotation.x = diveAngle;

                        // Move forward during the dive
                        fielder.translateZ(0.2);

                        if (diveProgress >= 1.0) {
                            clearInterval(diveInterval);
                            fielder.rotation.copy(originalRot); // Restore orientation
                            fielder.position.y = 0; // Ensure on ground
                            fielder.userData.isAnimating = false;
                        }
                    }, 30);
                }
            }

            celebrateVictory() {
                // Create Confetti
                const geometry = new THREE.BufferGeometry();
                const count = 1000;
                const positions = [];
                const colors = [];
                const velocities = [];
                
                for(let i=0; i<count; i++) {
                    positions.push((Math.random()-0.5)*50, 20 + Math.random()*10, (Math.random()-0.5)*50);
                    const color = new THREE.Color().setHSL(Math.random(), 1, 0.5);
                    colors.push(color.r, color.g, color.b);
                    velocities.push({x: (Math.random()-0.5)*0.5, y: -Math.random()*0.5 - 0.1, z: (Math.random()-0.5)*0.5});
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({ size: 0.8, vertexColors: true });
                this.confettiSystem = new THREE.Points(geometry, material);
                this.confettiSystem.userData = { velocities: velocities };
                this.scene.add(this.confettiSystem);
                this.confettiActive = true;
            }

            triggerVictoryAnimation(winningTeamPlayers) {
                const duration = 10000; // 10 seconds
                const startTime = Date.now();

                const intervalId = setInterval(() => {
                    const elapsedTime = Date.now() - startTime;
                    if (elapsedTime > duration) {
                        clearInterval(intervalId);
                        winningTeamPlayers.forEach(player => {
                            if (player) player.position.y = 0;
                        });
                        return;
                    }

                    // Simple jump animation
                    const jumpHeight = Math.abs(Math.sin(elapsedTime * 0.005)) * 0.5;
                    winningTeamPlayers.forEach(player => {
                        if (player) player.position.y = jumpHeight;
                    });
                }, 50); // Run every 50ms
            }

            resetFielderPositions() {
                this.fielders.forEach(fielder => {
                    if (fielder.userData.originalPosition) {
                        fielder.position.copy(fielder.userData.originalPosition);
                        fielder.lookAt(0, 0, -10); // Look towards batsman
                        fielder.position.y = 0; // Reset any running animation
                    }
                });
            }

            applyFieldingFormation(formationName) {
                const fPos = FIELD_PLACEMENTS[formationName];
                if (!fPos || fPos.length !== this.fielders.length) {
                    console.error(`Fielding formation "${formationName}" not found or has incorrect number of players.`);
                    return;
                }

                this.fielders.forEach((fielder, index) => {
                    const newPos = fPos[index];
                    if (newPos) {
                        // Update the original position so reset works correctly
                        fielder.userData.originalPosition.set(newPos.x, 0, newPos.z);
                    }
                });

                // Move fielders to their new positions
                this.resetFielderPositions();
            }

            createTargets() {
                this.clearTargets();
                const positions = [
                    {x: -15, y: 5, z: -30}, // Off side deep
                    {x: 15, y: 5, z: -30},  // Leg side deep
                    {x: 0, y: 8, z: -45},   // Straight screen
                    {x: -25, y: 4, z: -10}, // Point
                    {x: 25, y: 4, z: -10}   // Square leg
                ];
                positions.forEach(p => {
                    const geo = new THREE.RingGeometry(1.5, 2.5, 32);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(p.x, p.y, p.z);
                    mesh.lookAt(0, 0, -10);
                    this.scene.add(mesh);
                    this.targets.push(mesh);
                });
            }

            clearTargets() {
                this.targets.forEach(t => this.scene.remove(t));
                this.targets = [];
            }

            updateQuality(level) {
                if(level === 'low') {
                    this.renderer.shadowMap.enabled = false;
                    this.renderer.setPixelRatio(1); 
                } else if (level === 'medium') {
                    this.renderer.shadowMap.enabled = true;
                    this.renderer.shadowMap.type = THREE.BasicShadowMap;
                    this.renderer.setPixelRatio(window.devicePixelRatio);
                } else { // High
                    this.renderer.shadowMap.enabled = true;
                    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    this.renderer.setPixelRatio(window.devicePixelRatio);
                }
                
                if(this.dirLight) this.dirLight.castShadow = (level !== 'low');
                
                this.scene.traverse((child) => {
                    if (child.isMesh && child.material) child.material.needsUpdate = true;
                });
            }

            animate() {
                requestAnimationFrame(this.animate);
                const delta = this.clock.getDelta();

                const app = window.gameApp;

                // --- Intro & Countdown Logic ---
                if (this.animationState === 'intro') {
                    this.introAnimationTime += delta;
                    if (this.stadiumModel) {
                        this.stadiumModel.rotation.y += delta * 0.2; // Rotate stadium
                    }
                    // Use intro camera high up
                    this.introCamera.position.set(0, 50, 100);
                    this.introCamera.lookAt(0, 0, 0);
                    this.renderer.render(this.scene, this.introCamera);

                    if (this.introAnimationTime >= 7) {
                        this.animationState = 'countdown';
                        if (this.onIntroComplete) {
                            this.onIntroComplete();
                            this.onIntroComplete = null;
                        }
                    }
                    return; // Skip normal game render
                } else if (this.animationState === 'countdown') {
                    this.renderer.render(this.scene, this.introCamera);
                    return;
                }
                
                if (app && app.isPaused) {
                    this.renderer.render(this.scene, this.camera);
                    return;
                }

                // --- Bowling Manual Controls ---
                if (app && app.playerRole === 'bowling') {
                    // Bowler position movement (can be done anytime before delivery)
                    if (app.bowlingState === 'idle' || app.bowlingState === 'power') {
                        const moveSpeed = 0.05;
                        if (this.bowlerGroup && (app.activeKeys['a'] || app.activeKeys['ArrowLeft'])) {
                            if (this.bowlerGroup.position.x > -2) {
                                this.bowlerGroup.position.x -= moveSpeed;
                            }
                        }
                        if (this.bowlerGroup && (app.activeKeys['d'] || app.activeKeys['ArrowRight'])) {
                            if (this.bowlerGroup.position.x < 2) {
                                this.bowlerGroup.position.x += moveSpeed;
                            }
                        }
                    }

                    if (app.bowlingState === 'power') {
                        app.bowlingPower = (app.bowlingPower + 0.02) % 1.05; // Loop 0 to 1
                        const speedoBar = document.getElementById('speedo-bar');
                        if(speedoBar) speedoBar.style.height = Math.min(100, app.bowlingPower * 100) + '%';
                    }
                    if (app.bowlingState === 'aiming') {
                        // Use W/S/Arrows for aiming, A/D is for bowler position
                        if (!app.isSwiping) {
                            const aimSpeed = 0.1;
                            if (app.activeKeys['ArrowLeft']) app.bowlingAim.x -= aimSpeed;
                            if (app.activeKeys['ArrowRight']) app.bowlingAim.x += aimSpeed;
                            if (app.activeKeys['w'] || app.activeKeys['ArrowUp']) app.bowlingAim.z -= aimSpeed;
                            if (app.activeKeys['s'] || app.activeKeys['ArrowDown']) app.bowlingAim.z += aimSpeed;
                        }

                        // Clamp values
                        app.bowlingAim.x = THREE.MathUtils.clamp(app.bowlingAim.x, -1.5, 1.5);
                        app.bowlingAim.z = THREE.MathUtils.clamp(app.bowlingAim.z, -9.5, 5);

                        this.pitchMarker.position.copy(app.bowlingAim);
                    }
                }

                // --- Ball Physics (Centralized Loop) ---
                if (app && app.ballActive) {
                    app.updateBallPhysics();
                }

                // Batsman Movement Logic (polling from activeKeys)
                if (app && app.isGameActive && !app.isPaused && app.playerRole === 'batting' && this.batsmanGroup) {
                    const moveSpeed = 0.05; // A bit slower for smoother control
                    if (app.activeKeys['a'] || app.activeKeys['ArrowLeft']) {
                        if (this.batsmanGroup.position.x > -1) {
                            this.batsmanGroup.position.x -= moveSpeed;
                        }
                    }
                    if (app.activeKeys['d'] || app.activeKeys['ArrowRight']) {
                        if (this.batsmanGroup.position.x < 1) {
                            this.batsmanGroup.position.x += moveSpeed;
                        }
                    }
                }

                // Running Animation
                if (this.runAnim && this.runAnim.active) {
                    // Move Batsman
                    const batDir = Math.sign(this.runAnim.targetZ_Bat - this.batsmanGroup.position.z);
                    if (Math.abs(this.batsmanGroup.position.z - this.runAnim.targetZ_Bat) > 0.5) {
                        this.batsmanGroup.position.z += batDir * this.runAnim.speed;
                        this.batsmanGroup.position.y = Math.abs(Math.sin(Date.now() * 0.015)) * 0.3;
                    }

                    // Move Non-Striker
                    const nonDir = Math.sign(this.runAnim.targetZ_Non - this.nonStrikerGroup.position.z);
                    if (Math.abs(this.nonStrikerGroup.position.z - this.runAnim.targetZ_Non) > 0.5) {
                        this.nonStrikerGroup.position.z += nonDir * this.runAnim.speed;
                        this.nonStrikerGroup.position.y = Math.abs(Math.sin(Date.now() * 0.015)) * 0.3;
                    }

                    // Check completion
                    if (Math.abs(this.batsmanGroup.position.z - this.runAnim.targetZ_Bat) <= 0.5 &&
                        Math.abs(this.nonStrikerGroup.position.z - this.runAnim.targetZ_Non) <= 0.5) {
                        
                        this.runAnim.completed++;
                        if (this.runAnim.completed < this.runAnim.runs) {
                            // Swap targets for next run
                            const temp = this.runAnim.targetZ_Bat;
                            this.runAnim.targetZ_Bat = this.runAnim.targetZ_Non;
                            this.runAnim.targetZ_Non = temp;
                        } else {
                            this.runAnim.active = false;
                            this.batsmanGroup.position.y = 0;
                            this.nonStrikerGroup.position.y = 0;
                            
                            // Finalize positions and references
                            if (this.runAnim.runs % 2 !== 0) {
                                const tempGrp = this.batsmanGroup;
                                this.batsmanGroup = this.nonStrikerGroup;
                                this.nonStrikerGroup = tempGrp;
                            }
                            this.batsmanGroup.position.set(0, 0, -10);
                            this.batsmanGroup.rotation.y = 0;
                            this.nonStrikerGroup.position.set(-2, 0, 8);
                            this.nonStrikerGroup.rotation.y = Math.PI;
                            if(app) app.onRunComplete();
                        }
                    }
                }

                // Simple camera rotation for menu background effect if game not active
                if (!app || !app.isGameActive) {
                    this.camera.position.x = Math.sin(Date.now() * 0.0005) * 30;
                    this.camera.position.z = Math.cos(Date.now() * 0.0005) * 30;
                    this.camera.lookAt(0, 0, 0);
                    
                    // Rotate auction player if exists
                    if(this.displayPlayer) this.displayPlayer.rotation.y += 0.01;

                } else if (app.ballActive && app.shotPlayed) {
                    // Dynamic Camera: Follow the ball
                    const targetPos = this.ball.position.clone();
                    // Offset camera slightly behind and above ball
                    this.camera.position.lerp(new THREE.Vector3(targetPos.x, targetPos.y + 2, targetPos.z - 5), 0.1);
                    this.camera.lookAt(targetPos);
                    // --- UPDATED FIELDER LOGIC CALL ---
                    const isAerial = this.ball.position.y > 2.0;
                    this.updateFielders(this.ball.position, app.ballVelocity, isAerial);
                } else {
                    // Static Gameplay Cameras (Pre-shot)
                    if (app.playerRole === 'bowling') {
                        // Bowling Camera
                        this.camera.position.set(0, 5, 25);
                        this.camera.lookAt(0, 0, -20);
                    } else { // Batting
                        // Batting Stance based on Camera Mode
                        if (app.currentCameraMode === 'Bowler') {
                            this.camera.position.set(0, 5, 18); // Zoomed in
                            this.camera.lookAt(0, 0, -20);
                        } else if (app.currentCameraMode === 'Broadcast') {
                            this.camera.position.set(-10, 5, 0); // Zoomed in
                            this.camera.lookAt(0, 0, 0);
                        } else {
                            // Default: Batsman
                            this.camera.position.set(0, 4, -18); // Zoomed in
                            this.camera.lookAt(0, 1, -10); // Look at the batsman
                        }
                    }
                } 

                // Camera Shake Effect
                if(this.shakeIntensity > 0) {
                    this.camera.position.x += (Math.random() - 0.5) * this.shakeIntensity;
                    this.camera.position.y += (Math.random() - 0.5) * this.shakeIntensity;
                    this.shakeIntensity *= 0.9; // Decay
                }

                // Update Particles
                for(let i=this.particles.length-1; i>=0; i--) {
                    const p = this.particles[i];
                    p.position.add(p.userData.velocity);
                    p.userData.velocity.y -= 0.01; // Gravity
                    if(p.position.y < 0) {
                        this.scene.remove(p);
                        this.particles.splice(i, 1);
                    }
                }

                // Confetti Animation
                if (this.confettiActive && this.confettiSystem) {
                    const positions = this.confettiSystem.geometry.attributes.position.array;
                    const vels = this.confettiSystem.userData.velocities;
                    
                    for(let i=0; i<vels.length; i++) {
                        positions[i*3] += vels[i].x;
                        positions[i*3+1] += vels[i].y;
                        positions[i*3+2] += vels[i].z;
                        
                        if(positions[i*3+1] < 0) positions[i*3+1] = 20 + Math.random()*10; // Reset height
                    }
                    this.confettiSystem.geometry.attributes.position.needsUpdate = true;
                }

                // Update Trail if ball is active
                if(app && app.ballActive && this.ball.visible) {
                    this.updateTrail(this.ball.position);
                }

                // Update Fireworks
                for(let i=this.fireworks.length-1; i>=0; i--) {
                    const fw = this.fireworks[i];
                    const positions = fw.geometry.attributes.position.array;
                    const vels = fw.userData.velocities;
                    fw.userData.life -= 0.015;
                    
                    for(let j=0; j<vels.length; j++) {
                        positions[j*3] += vels[j].x;
                        positions[j*3+1] += vels[j].y;
                        positions[j*3+2] += vels[j].z;
                        vels[j].y -= 0.02; // Gravity
                    }
                    fw.geometry.attributes.position.needsUpdate = true;
                    fw.material.opacity = fw.userData.life;
                    
                    if(fw.userData.life <= 0) {
                        this.scene.remove(fw);
                        this.fireworks.splice(i, 1);
                    }
                }

                this.renderer.render(this.scene, this.camera);
            }

            triggerRun(runs) {
                this.runAnim = {
                    active: true,
                    runs: runs,
                    completed: 0,
                    targetZ_Bat: 10,
                    targetZ_Non: -10,
                    speed: 0.25
                };
                if(window.gameApp) window.gameApp.isRunning = true;
            }

            startIntroAnimation(onComplete) {
                // If stadium isn't loaded yet, just start the match immediately
                if (!this.stadiumModel) {
                    console.log("Stadium not ready, skipping intro");
                    if(onComplete) onComplete(); 
                    return;
                }
                this.onIntroComplete = onComplete;
                this.animationState = 'intro';
                this.introAnimationTime = 0;
                this.stadiumModel.rotation.y = 0; 
                
                // Set Intro Camera Position
                this.introCamera.position.set(0, 60, 120);
                this.introCamera.lookAt(0, 0, 0);
                
                console.log("Starting intro animation...");
            }
        } // End of Game3D Class
        

        // --- SYSTEM: App Manager ---
        class GameApp {
            constructor() {
                window.gameApp = this;
                this.game3D = new Game3D();
                this.isGameActive = false;
                this.ballActive = false;
                this.isPaused = false;
                this.shotPlayed = false;
                this.ballVelocity = new THREE.Vector3();
                this.userTeamId = 'MI';
                this.soundManager = new SoundManager();
                this.currentOpponent = null;
                this.target = null;
                this.currentBatsman = null;
                this.currentNonStriker = null;
                this.currentBowler = null;
                this.playing11 = [];
                this.battedPlayers = []; // IDs or indices of players who are out or playing
                this.tempSelection = []; // For openers
                this.activeKeys = {};
                this.bowlingType = 'Fast';
                this.innings = 1;
                this.tournamentStage = 'league'; // league, semi-final, final, completed
                this.finalOpponentId = null;
                this.checkSaveGame();
                this.bowlingPower = 0;
                this.isSwiping = false;
                this.touchStartPos = null;
                this.initialAimPos = null;
                this.bowlingAim = new THREE.Vector3(0, 0.05, -5); // Default aim
                this.isUserCurrentlyBowling = false;
                this.currentSpinX = 0;
                this.bowlingState = 'idle';

                this.isRunning = false;
                this.waitingForRun = false;
                this.bowlerInterval = null;
                this.firstInningsBalls = 0;
                this.isPracticeMode = false;
                this.isTargetMode = false;
                this.targetScore = 0;
                this.targetBalls = 0;
                this.pendingFreeHit = false;
                this.isFreeHit = false;
                this.cameraModes = ['Batsman', 'Bowler', 'Broadcast'];
                this.currentCameraMode = 'Batsman';
                this.isSuperOver = false;
                this.isReplayActive = false; // For commentary delay on boundaries
                this.isMasterMuted = false;
                this.isPotentialCatch = false;
                this.isCommentaryMuted = false;
                this.isCrowdMuted = false;
                this.aiBowlingLineup = [];
                this.formationTypes = ['Default', 'Aggressive', 'Defensive', 'Powerplay', 'Leg Side Attack'];
                this.currentFormation = 'Default';
                this.bowlingVariation = 'Normal';
                
                
                this.touchStartX = 0; // For batsman swipe movement
                
                // Score State
                this.runs = 0;
                this.wickets = 0;
                this.ballsBowled = 0;
                this.matchOvers = parseInt(document.getElementById('overs-select').value) || 2;
                
                this.setupControls();
                this.settings = { masterVolume: 1.0, commentaryVolume: 1.0, crowdVolume: 1.0, graphics: 'high' }; // Default settings
                this.setupTouchControls();
                this.loadSettings();
                this.bindUIEvents();
            }

            showScreen(id) {
                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                const screen = document.getElementById(id);
                if(screen) screen.classList.add('active');

                // When the menu screen is shown, request the banner ad.
                if (id === 'menu-screen') {
                    try {
                        // This will fill the <ins> tag on the menu screen.
                        (adsbygoogle = window.adsbygoogle || []).push({});
                    } catch (e) {
                        console.error("AdSense push error:", e);
                    }
                }
            }

            bindUIEvents() {
                const get = (id) => document.getElementById(id);

                // Main Menu
                get('btn-new-career').onclick = () => this.startNewCareer();
                get('btn-practice-mode').onclick = () => this.showScreen('practice-select-screen');
                get('btn-target-practice').onclick = () => this.startTargetPractice();
                get('resume-btn').onclick = () => this.loadCareer();
                get('btn-settings').onclick = () => this.showScreen('settings-screen');
                get('btn-help').onclick = () => this.showScreen('help-screen');

                // Practice Select
                get('btn-practice-batting').onclick = () => this.startPracticeMode();
                get('btn-practice-bowling').onclick = () => this.startBowlingPractice();
                get('btn-back-from-practice-select').onclick = () => this.showScreen('menu-screen');

                // Team Select
                get('btn-confirm-team').onclick = () => this.confirmTeam();
                get('btn-back-from-team').onclick = () => this.showScreen('menu-screen');

                // Settings
                get('master-vol-slider').oninput = (e) => this.updateMasterVolume(e.target.value);
                get('commentary-vol-slider').oninput = (e) => this.updateCommentaryVolume(e.target.value);
                get('crowd-vol-slider').oninput = (e) => this.updateCrowdVolume(e.target.value);
                get('graphics-select').onchange = (e) => this.updateGraphics(e.target.value);
                get('btn-back-from-settings').onclick = () => this.showScreen('menu-screen');

                // Help
                get('btn-back-from-help').onclick = () => this.showScreen('menu-screen');

                // Auction
                get('btn-bid').onclick = () => window.auctionSystem.placeBid();
                get('btn-skip-player').onclick = () => window.auctionSystem.skipPlayer();
                get('btn-autofill-squad').onclick = () => window.auctionSystem.autoFillSquad();
                get('btn-finish-auction').onclick = () => window.auctionSystem.finishAuction();

                // Squad
                get('btn-back-to-auction').onclick = () => this.showScreen('auction-screen');

                // Toss
                get('btn-toss-heads').onclick = () => this.tossCoin('Heads');
                get('btn-toss-tails').onclick = () => this.tossCoin('Tails');
                get('btn-decision-bat').onclick = () => this.setDecision('bat');
                get('btn-decision-bowl').onclick = () => this.setDecision('bowl');
                get('btn-start-match-from-toss').onclick = () => this.startMatchFromToss();

                // Tournament Hub
                get('tournament-action-btn').onclick = () => this.playNextMatch();

                // Playing 11, Batsman/Bowler Select, Summary, HUD
                get('btn-confirm-p11').onclick = () => this.confirmPlaying11();
                get('confirm-batsman-btn').onclick = () => this.confirmBatsmanSelection();
                get('btn-confirm-bowler').onclick = () => this.confirmBowlerSelection();
                get('btn-continue-tournament').onclick = () => this.startTournament();
                get('pause-btn').onclick = () => this.togglePause();
                get('exit-btn').onclick = () => this.exitMatch();
                get('cam-btn').onclick = () => this.cycleCamera();
                get('master-sound-btn').onclick = () => this.toggleMasterSound();
                get('commentary-mute-btn').onclick = () => this.toggleCommentaryMute();
                get('crowd-mute-btn').onclick = () => this.toggleCrowdMute();
                get('field-btn').onclick = () => this.cycleFieldingFormation();

                // Bowling Variations
                get('btn-inswing').onclick = () => this.setBowlingVariation('InSwing');
                get('btn-outswing').onclick = () => this.setBowlingVariation('OutSwing');
                get('btn-slower').onclick = () => this.setBowlingVariation('Slower');
                get('btn-normal').onclick = () => this.setBowlingVariation('Normal');
            }

            goFullscreenAndLockOrientation() {
                // This function was missing, causing the game to not start in any mode.
                // It attempts to go fullscreen and lock orientation, but always resolves
                // to ensure the game can proceed even if these actions fail.
                console.log("Attempting to go fullscreen and lock orientation...");
                try {
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen().catch(err => {
                            console.warn(`Fullscreen request failed: ${err.message}`);
                        });
                    }
                    // Screen orientation lock is often restricted and might fail.
                    if (screen.orientation && screen.orientation.lock) {
                        screen.orientation.lock('landscape').catch(err => {
                            console.warn(`Orientation lock failed: ${err.message}`);
                        });
                    }
                } catch (err) {
                    console.warn("Error during fullscreen/orientation lock:", err);
                }
                return Promise.resolve(); // Crucially, always resolve the promise to continue game flow.
            }

            cycleFieldingFormation() {
                if (this.playerRole !== 'bowling') {
                    this.showCommentary("Can only change field when bowling", false);
                    return;
                }
                const currentIndex = this.formationTypes.indexOf(this.currentFormation);
                const nextIndex = (currentIndex + 1) % this.formationTypes.length;
                const newFormation = this.formationTypes[nextIndex];
                this.setFieldingFormation(newFormation);
                if(document.activeElement) document.activeElement.blur();
            }

            setFieldingFormation(formationName) {
                this.currentFormation = formationName;
                this.game3D.applyFieldingFormation(formationName);
                this.showCommentary(`Field: ${formationName}`, false);
            }

            setBowlingVariation(type) {
                this.bowlingVariation = type;
                this.showCommentary(type, false);
                // Highlight active button
                ['btn-inswing', 'btn-outswing', 'btn-slower', 'btn-normal'].forEach(id => {
                    const btn = document.getElementById(id);
                    if(btn) btn.style.borderColor = (id === `btn-${type.toLowerCase()}`) ? 'gold' : 'white';
                });
            }

            // Helper functions for audio controls

            checkSaveGame() {
                if(localStorage.getItem('cricket_career_2025')) {
                    document.getElementById('resume-btn').style.display = 'inline-block';
                }
            }

            loadSettings() {
                const s = localStorage.getItem('cricket_settings_2025');
                if (s) {
                    try {
                        const loadedSettings = JSON.parse(s);
                        if (typeof loadedSettings === 'object' && loadedSettings !== null) {
                            Object.assign(this.settings, loadedSettings);
                            // Restore mute states, which are now saved inside the settings object
                            this.isMasterMuted = this.settings.isMasterMuted || false;
                            this.isCommentaryMuted = this.settings.isCommentaryMuted || false;
                            this.isCrowdMuted = this.settings.isCrowdMuted || false;
                        }
                    } catch (e) {
                        console.error("Could not load settings, using defaults. Corrupted data cleared.", e);
                        localStorage.removeItem('cricket_settings_2025'); // Clear corrupted data
                    }
                }

                // Apply master volume
                const masterVolSlider = document.getElementById('master-vol-slider');
                if(masterVolSlider) {
                    masterVolSlider.value = this.settings.masterVolume;
                    document.getElementById('vol-display').innerText = Math.round(this.settings.masterVolume * 100) + "%";
                }
                // Apply commentary volume
                const commentaryVolSlider = document.getElementById('commentary-vol-slider');
                if(commentaryVolSlider) {
                    commentaryVolSlider.value = this.settings.commentaryVolume;
                    document.getElementById('commentary-vol-display').innerText = Math.round(this.settings.commentaryVolume * 100) + "%";
                }
                // Apply crowd volume
                const crowdVolSlider = document.getElementById('crowd-vol-slider');
                if(crowdVolSlider) {
                    crowdVolSlider.value = this.settings.crowdVolume;
                    document.getElementById('crowd-vol-display').innerText = Math.round(this.settings.crowdVolume * 100) + "%";
                }

                if(this.soundManager) {
                    // Apply mute states first, then volumes
                    this.applyMuteStatesToSoundManager();
                    // Update UI buttons based on restored mute states
                    this.updateMuteButtonsUI();
                }

                const graphSelect = document.getElementById('graphics-select');
                if(graphSelect) graphSelect.value = this.settings.graphics;
                if(this.game3D) this.game3D.updateQuality(this.settings.graphics);
            }

            updateMuteButtonsUI() {
                const masterSoundBtn = document.getElementById('master-sound-btn');
                if (masterSoundBtn) masterSoundBtn.innerText = this.isMasterMuted ? 'üîá' : 'üîä';

                const commentaryMuteBtn = document.getElementById('commentary-mute-btn');
                if (commentaryMuteBtn) commentaryMuteBtn.innerText = this.isCommentaryMuted ? 'üîï' : 'üó£Ô∏è';

                const crowdMuteBtn = document.getElementById('crowd-mute-btn');
                if (crowdMuteBtn) crowdMuteBtn.innerText = this.isCrowdMuted ? 'üîá' : 'üèüÔ∏è';
            }

            applyMuteStatesToSoundManager() {
                if (!this.soundManager) return;

                // Master mute overrides all
                if (this.isMasterMuted) {
                    this.soundManager.setMasterVolume(0);
                    this.soundManager.setCommentaryVolume(0);
                    this.soundManager.stopCrowdLoop();
                    this.soundManager.setCrowdVolume(0);
                } else {
                    this.soundManager.setMasterVolume(this.settings.masterVolume);
                    // Restore commentary and crowd volumes if they were not individually muted
                    if (!this.isCommentaryMuted) {
                        this.soundManager.setCommentaryVolume(this.settings.commentaryVolume);
                    } else {
                        this.soundManager.setCommentaryVolume(0); // Still muted individually
                    }
                    
                    if (!this.isCrowdMuted) {
                        this.soundManager.setCrowdVolume(this.settings.crowdVolume);
                        if (this.settings.crowdVolume > 0) this.soundManager.playCrowdLoop();
                        else this.soundManager.stopCrowdLoop();
                    } else {
                        this.soundManager.stopCrowdLoop();
                        this.soundManager.setCrowdVolume(0); // Still muted individually
                    }
                }
            }
            cycleCamera() {
                const idx = this.cameraModes.indexOf(this.currentCameraMode);
                this.currentCameraMode = this.cameraModes[(idx + 1) % this.cameraModes.length];
                this.showCommentary("Cam: " + this.currentCameraMode, false);
                if(document.activeElement) document.activeElement.blur(); // Remove focus
            }            

            saveSettings() {
                this.settings.isMasterMuted = this.isMasterMuted;
                this.settings.isCommentaryMuted = this.isCommentaryMuted;
                this.settings.isCrowdMuted = this.isCrowdMuted;
                localStorage.setItem('cricket_settings_2025', JSON.stringify(this.settings));
            }

            updateMasterVolume(val) {
                this.settings.masterVolume = parseFloat(val);
                if (this.isMasterMuted && val > 0) { this.isMasterMuted = false; document.getElementById('master-sound-btn').innerText = 'üîä'; }
                else if (!this.isMasterMuted && val == 0) { this.isMasterMuted = true; document.getElementById('master-sound-btn').innerText = 'üîá'; }
                this.applyMuteStatesToSoundManager(); // Apply new volume and respect mute states
                this.updateMuteButtonsUI(); // Update button icon if mute state changed
                document.getElementById('vol-display').innerText = Math.round(this.settings.masterVolume * 100) + "%";
                this.saveSettings();
            }

            updateCommentaryVolume(val) {
                this.settings.commentaryVolume = parseFloat(val);
                if (this.isCommentaryMuted && val > 0) { this.isCommentaryMuted = false; document.getElementById('commentary-mute-btn').innerText = 'üó£Ô∏è'; }
                else if (!this.isCommentaryMuted && val == 0) { this.isCommentaryMuted = true; document.getElementById('commentary-mute-btn').innerText = 'üîï'; }
                this.applyMuteStatesToSoundManager(); // Apply new volume and respect mute states
                this.updateMuteButtonsUI(); // Update button icon if mute state changed
                document.getElementById('commentary-vol-display').innerText = Math.round(this.settings.commentaryVolume * 100) + "%";
                this.saveSettings();
            }

            updateCrowdVolume(val) {
                this.settings.crowdVolume = parseFloat(val);
                if (this.isCrowdMuted && val > 0) { this.isCrowdMuted = false; }
                else if (!this.isCrowdMuted && val == 0) { this.isCrowdMuted = true; }
                this.applyMuteStatesToSoundManager(); // Apply new volume and respect mute states
                this.updateMuteButtonsUI(); // Update button icon if mute state changed
                document.getElementById('crowd-vol-display').innerText = Math.round(this.settings.crowdVolume * 100) + "%";
                this.saveSettings();
            }

            updateGraphics(val) {
                this.settings.graphics = val;
                this.game3D.updateQuality(val);
                this.saveSettings();
            }            

            // Mute/Unmute Toggles
            // These functions now primarily toggle the mute state and then call the helper to apply changes
            // This ensures consistency across all audio controls.
            startNewCareer() {
                this.isPracticeMode = false;
                this.isTargetMode = false;
                this.pendingFreeHit = false;
                if(localStorage.getItem('cricket_career_2025')) {
                    if(!confirm("Start new career? Previous save will be overwritten.")) return;
                }
                localStorage.removeItem('cricket_career_2025');
                this.resetTournamentData();
                this.showTeamSelect();
            }

            resetTournamentData() {
                TEAMS.forEach(t => { 
                    t.played = 0; t.won = 0; t.pts = 0; 
                    t.runsScored = 0; t.ballsFaced = 0; t.runsConceded = 0; t.ballsBowled = 0;
                });
                this.tournamentStage = 'league';
                this.finalOpponentId = null;
                if(window.auctionSystem) {
                    auctionSystem.mySquad = [];
                    auctionSystem.userBudget = 120.0;
                    auctionSystem.userSquadCount = 0;
                    auctionSystem.currentPlayerIndex = 0;
                    auctionSystem.isAuctionComplete = false;
                }
            }

            toggleMasterSound() {
                this.isMasterMuted = !this.isMasterMuted;
                this.applyMuteStatesToSoundManager();
                this.updateMuteButtonsUI();
                if(document.activeElement) document.activeElement.blur();
                this.saveSettings();
            }

            toggleCommentaryMute() {
                this.isCommentaryMuted = !this.isCommentaryMuted;
                this.applyMuteStatesToSoundManager();
                this.updateMuteButtonsUI();
                if(document.activeElement) document.activeElement.blur();
                this.saveSettings();
            }

            toggleCrowdMute() {
                this.isCrowdMuted = !this.isCrowdMuted;
                this.applyMuteStatesToSoundManager();
                this.updateMuteButtonsUI();
                if(document.activeElement) document.activeElement.blur();
                this.saveSettings();
            }

            // Original loadCareer() logic, now simplified due to loadSettings() updates
            // ... (rest of the loadCareer function)
            // Restore new audio settings
            // if (data.settings) Object.assign(this.settings, data.settings);
            // this.isMasterMuted = data.isMasterMuted || false;
            // this.isCommentaryMuted = data.isCommentaryMuted || false;
            // this.isCrowdMuted = data.isCrowdMuted || false;
            // this.loadSettings(); // This will now correctly apply all settings and mute states
            // The lines below are redundant if loadSettings() is called and updated
            // document.getElementById('master-sound-btn').innerText = this.isMasterMuted ? 'üîá' : 'üîä';
            // document.getElementById('commentary-mute-btn').innerText = this.isCommentaryMuted ? 'üîï' : 'üó£Ô∏è';
            // document.getElementById('crowd-mute-btn').innerText = this.isCrowdMuted ? 'üîá' : 'üèüÔ∏è';

            saveCareer() {
                const data = {
                    userTeamId: this.userTeamId,
                    teams: TEAMS,
                    mySquad: auctionSystem.mySquad,
                    settings: this.settings,
                    budget: auctionSystem.userBudget,
                    squadCount: auctionSystem.userSquadCount,
                    auctionIndex: auctionSystem.currentPlayerIndex,
                    isAuctionComplete: auctionSystem.isAuctionComplete,
                    playerList: PLAYERS_2025,
                    tournamentStage: this.tournamentStage,
                    finalOpponentId: this.finalOpponentId
                };
                localStorage.setItem('cricket_career_2025', JSON.stringify(data));
                this.checkSaveGame();
            }

            loadCareer() {
                this.isPracticeMode = false;
                this.isTargetMode = false;
                this.pendingFreeHit = false;
                const json = localStorage.getItem('cricket_career_2025');
                if (!json) return;

                let data;
                try {
                    data = JSON.parse(json);
                } catch (e) {
                    console.error("Failed to parse career save. Data is corrupted.", e);
                    alert("Your saved game is corrupted and cannot be loaded. The corrupted save file will be deleted.");
                    localStorage.removeItem('cricket_career_2025');
                    this.checkSaveGame(); // This will hide the resume button
                    return;
                }

                // Restore Players
                if(data.playerList) PLAYERS_2025.splice(0, PLAYERS_2025.length, ...data.playerList);

                this.userTeamId = data.userTeamId;
                auctionSystem.userTeamId = data.userTeamId;
                
                // Restore Teams
                data.teams.forEach(t => { 
                    const original = TEAMS.find(ot => ot.id === t.id); 
                    if(original) {
                        Object.assign(original, t);
                        if(original.runsScored === undefined) { original.runsScored = 0; original.ballsFaced = 0; original.runsConceded = 0; original.ballsBowled = 0; }
                    }
                });

                // Restore Auction
                auctionSystem.mySquad = data.mySquad;
                auctionSystem.userBudget = data.budget;
                auctionSystem.userSquadCount = data.squadCount;
                auctionSystem.currentPlayerIndex = data.auctionIndex;
                auctionSystem.isAuctionComplete = data.isAuctionComplete;
                this.tournamentStage = data.tournamentStage || 'league';
                this.finalOpponentId = data.finalOpponentId || null;

                // Restore audio and graphics settings from the career save
                if (data.settings) {
                    Object.assign(this.settings, data.settings);
                    // Restore mute states which are now saved inside the settings object
                    this.isMasterMuted = data.settings.isMasterMuted || false;
                    this.isCommentaryMuted = data.settings.isCommentaryMuted || false;
                    this.isCrowdMuted = data.settings.isCrowdMuted || false;
                }

                // Apply loaded settings to UI and SoundManager
                const masterVolSlider = document.getElementById('master-vol-slider');
                if(masterVolSlider) { masterVolSlider.value = this.settings.masterVolume; if(document.getElementById('vol-display')) document.getElementById('vol-display').innerText = Math.round(this.settings.masterVolume * 100) + "%"; }
                const commentaryVolSlider = document.getElementById('commentary-vol-slider');
                if(commentaryVolSlider) { commentaryVolSlider.value = this.settings.commentaryVolume; if(document.getElementById('commentary-vol-display')) document.getElementById('commentary-vol-display').innerText = Math.round(this.settings.commentaryVolume * 100) + "%"; }
                const crowdVolSlider = document.getElementById('crowd-vol-slider');
                if(crowdVolSlider) { crowdVolSlider.value = this.settings.crowdVolume; if(document.getElementById('crowd-vol-display')) document.getElementById('crowd-vol-display').innerText = Math.round(this.settings.crowdVolume * 100) + "%"; }

                if(this.soundManager) {
                    this.applyMuteStatesToSoundManager();
                    this.updateMuteButtonsUI();
                }
                const graphSelect = document.getElementById('graphics-select');
                if(graphSelect) { graphSelect.value = this.settings.graphics; }
                if(this.game3D) { this.game3D.updateQuality(this.settings.graphics); }

                if(data.isAuctionComplete) this.startTournament(); else this.startAuction();
            }

            showTeamSelect() {
                this.showScreen('team-select-screen');
                const select = document.getElementById('team-dropdown');
                select.innerHTML = '';
                TEAMS.forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t.id;
                    opt.innerText = t.name;
                    select.appendChild(opt);
                });
            }

            confirmTeam() {
                this.userTeamId = document.getElementById('team-dropdown').value;
                auctionSystem.userTeamId = this.userTeamId;
                this.startAuction();
            }

            startAuction() {
                this.showScreen('auction-screen');
                auctionSystem.start();
            }

            startPracticeMode() {
                this.goFullscreenAndLockOrientation().then(() => {
                    this.isPracticeMode = true;
                    this.pendingFreeHit = false;
                    this.userTeamId = 'MI';
                    this.playerRole = 'batting';
                    this.currentOpponent = TEAMS.find(t => t.id === 'CSK');
                    this.innings = 1;
                    
                    // Create dummy squad for practice
                    this.matchSquad = PLAYERS_2025.slice(0, 11);
                    this.playing11 = this.matchSquad.map((_, i) => i);
                    
                    // Reset stats
                    this.matchSquad.forEach(p => { p.matchRuns = 0; p.matchBalls = 0; });

                    // Select Openers
                    this.currentBatsman = this.matchSquad[0];
                    this.currentNonStriker = this.matchSquad[1];
                    this.battedPlayers = [0, 1];

                    this.startMatch();
                    this.showCommentary("Practice Mode: Endless Batting", true);
                });
            }

            startBowlingPractice() {
                this.goFullscreenAndLockOrientation().then(() => {
                    this.isPracticeMode = true;
                    this.isTargetMode = false;
                    this.pendingFreeHit = false;
                    this.userTeamId = 'MI';
                    this.currentOpponent = TEAMS.find(t => t.id === 'CSK');
                    this.innings = 1;

                    this.playerRole = 'bowling'; // Set the role for bowling
 
                    // Create dummy squad for practice
                    this.matchSquad = PLAYERS_2025.slice(0, 11);
                    this.playing11 = this.matchSquad.map((_, i) => i);

                    // Reset stats for bowlers
                    this.matchSquad.forEach(p => {
                        p.matchWickets = 0;
                        p.matchRunsConceded = 0;
                        p.matchBallsBowled = 0;
                    });

                    this.currentBowler = this.matchSquad.find(p => p.role === 'Bowler' || p.role === 'All-Rounder') || this.matchSquad[0];
                    this.startMatch();
                    this.showCommentary("Practice Mode: Endless Bowling", true);
                });
            }

            startTargetPractice() {
                this.goFullscreenAndLockOrientation().then(() => {
                    this.isTargetMode = true;
                    this.isPracticeMode = false;
                    this.pendingFreeHit = false;
                    this.targetScore = 0;
                    this.targetBalls = 12; // 2 overs challenge
                    
                    this.userTeamId = 'MI'; 
                    this.currentOpponent = TEAMS.find(t => t.id === 'CSK');
                    this.matchSquad = PLAYERS_2025.slice(0, 11);
                    this.playing11 = this.matchSquad.map((_, i) => i);
                    
                    this.currentBatsman = this.matchSquad[0];
                    this.currentNonStriker = this.matchSquad[1];
                    this.battedPlayers = [0, 1];

                    this.playerRole = 'batting'; // Set role for batting
                    this.startMatch();
                    this.showCommentary("Target Mode: Hit Green Zones!", true);
                });
            }

            startTournament() {
                this.showScreen('tournament-screen');
                document.getElementById('user-team-title').innerText = "Your Team: " + TEAMS.find(t=>t.id === this.userTeamId).name;
                this.updatePointsTable();
                this.updateTournamentButton();
                this.saveCareer(); // Save when entering tournament hub
            }

            updatePointsTable() {
                const tbody = document.getElementById('points-body');
                tbody.innerHTML = '';
                
                // Calculate NRR and Sort
                const sortedTeams = [...TEAMS].sort((a,b) => {
                    if(b.pts !== a.pts) return b.pts - a.pts;
                    if(b.won !== a.won) return b.won - a.won;
                    
                    const nrrA = (a.ballsFaced > 0 ? a.runsScored / (a.ballsFaced/6) : 0) - (a.ballsBowled > 0 ? a.runsConceded / (a.ballsBowled/6) : 0);
                    const nrrB = (b.ballsFaced > 0 ? b.runsScored / (b.ballsFaced/6) : 0) - (b.ballsBowled > 0 ? b.runsConceded / (b.ballsBowled/6) : 0);
                    return nrrB - nrrA;
                });
                
                sortedTeams.forEach((t, index) => {
                    const nrr = ((t.ballsFaced > 0 ? t.runsScored / (t.ballsFaced/6) : 0) - (t.ballsBowled > 0 ? t.runsConceded / (t.ballsBowled/6) : 0)).toFixed(3);
                    
                    const row = `<tr>
                        <td>${index + 1}</td>
                        <td>${t.name}</td>
                        <td>${t.played}</td>
                        <td>${t.won}</td>
                        <td>${t.played - t.won}</td>
                        <td>${t.pts}</td>
                        <td>${nrr}</td>
                    </tr>`;
                    tbody.innerHTML += row;
                });
            }

            updateTournamentButton() {
                const btn = document.getElementById('tournament-action-btn');
                if(!btn) return;
                
                if (this.tournamentStage === 'completed') {
                    btn.innerText = "Start New Career";
                    btn.style.background = "#dd1f2d"; 
                } else {
                    btn.innerText = "Play Next Match";
                    btn.style.background = ""; 
                }
            }

            playNextMatch() {
                const myTeam = TEAMS.find(t => t.id === this.userTeamId);
                const LEAGUE_MATCHES = 5;
                const simOvers = parseInt(document.getElementById('overs-select').value) || 2;

                if (this.tournamentStage === 'completed') {
                    alert("Tournament Finished! Start a New Career.");
                    return;
                }

                if (this.tournamentStage === 'league') {
                    if (myTeam.played >= LEAGUE_MATCHES) {
                        // End of League - Check Qualification (Sort by Pts -> Won -> NRR)
                        const sorted = [...TEAMS].sort((a,b) => {
                            if(b.pts !== a.pts) return b.pts - a.pts;
                            if(b.won !== a.won) return b.won - a.won;
                            const nrrA = (a.ballsFaced > 0 ? a.runsScored / (a.ballsFaced/6) : 0) - (a.ballsBowled > 0 ? a.runsConceded / (a.ballsBowled/6) : 0);
                            const nrrB = (b.ballsFaced > 0 ? b.runsScored / (b.ballsFaced/6) : 0) - (b.ballsBowled > 0 ? b.runsConceded / (b.ballsBowled/6) : 0);
                            return nrrB - nrrA;
                        });
                        const myRank = sorted.findIndex(t => t.id === this.userTeamId);
                        
                        if (myRank < 4) {
                            this.tournamentStage = 'semi-final';
                            alert(`Qualified for Semi-Finals! You finished #${myRank+1}`);
                            
                            // Opponent Logic: 1vs4, 2vs3
                            const oppRank = 3 - myRank; 
                            this.currentOpponent = sorted[oppRank];
                            
                            // Simulate other SF to find Final Opponent
                            const other1 = sorted.find((_, i) => i !== myRank && i !== oppRank);
                            const other2 = sorted.find((_, i) => i !== myRank && i !== oppRank && i !== sorted.indexOf(other1));
                            this.finalOpponentId = (Math.random() > 0.5) ? other1.id : other2.id;
                        } else {
                            alert("You did not qualify for the playoffs. Better luck next time!");
                            this.tournamentStage = 'completed';
                            this.updateTournamentButton();
                            return;
                        }
                    } else {
                        // Regular League Match
                        const opponents = TEAMS.filter(t => t.id !== this.userTeamId);
                        this.currentOpponent = opponents[Math.floor(Math.random() * opponents.length)];
                        
                        // Simulate other matches
                        TEAMS.forEach(t => {
                            if(t.id !== this.userTeamId && t.id !== this.currentOpponent.id) {
                                t.played++;
                                const runs = Math.floor(Math.random() * (12 * simOvers - 6 * simOvers) + 6 * simOvers);
                                const oppRuns = Math.floor(Math.random() * (12 * simOvers - 6 * simOvers) + 6 * simOvers);
                                
                                t.runsScored += runs;
                                t.ballsFaced += simOvers * 6;
                                t.runsConceded += oppRuns;
                                t.ballsBowled += simOvers * 6;

                                if(runs > oppRuns) { 
                                    t.won++; t.pts += 2; 
                                }
                            }
                        });
                    }
                } else if (this.tournamentStage === 'final') {
                    this.currentOpponent = TEAMS.find(t => t.id === this.finalOpponentId);
                    alert(`FINAL MATCH vs ${this.currentOpponent.name}`);
                }

                this.innings = 1;
                
                // Go to Playing 11 Selection instead of Toss directly
                this.showPlaying11Selector();
            }

            resetMatchStats() {
                if(auctionSystem.mySquad) {
                    auctionSystem.mySquad.forEach(p => {
                        p.matchRuns = 0;
                        p.matchBalls = 0;
                        p.matchWickets = 0;
                        p.matchRunsConceded = 0;
                        p.matchBallsBowled = 0;
                    });
                }
            }

            showPlaying11Selector() {
                this.showScreen('playing11-screen');
                const container = document.getElementById('p11-list');
                container.innerHTML = '';
                this.playing11 = []; // Reset

                if(auctionSystem.mySquad.length === 0) {
                    // Demo mode if no squad
                    alert("No squad found! Using demo players.");
                    auctionSystem.mySquad = PLAYERS_2025.slice(0, 15);
                }
                
                this.resetMatchStats(); // Reset stats before new match selection

                auctionSystem.mySquad.forEach((p, i) => {
                    const div = document.createElement('div');
                    div.className = 'player-card-select';
                    div.innerHTML = `<b>${p.name}</b><br><small>${p.role}</small><br>Pow: ${p.power}`;
                    div.onclick = () => {
                        if(this.playing11.includes(i)) {
                            this.playing11 = this.playing11.filter(idx => idx !== i);
                            div.classList.remove('selected');
                        } else {
                            if(this.playing11.length < 11) {
                                this.playing11.push(i);
                                div.classList.add('selected');
                            } else {
                                alert("You can only select 11 players!");
                            }
                        }
                    };
                    container.appendChild(div);
                });
            }

            confirmPlaying11() {
                if(this.playing11.length !== 11 && this.playing11.length !== auctionSystem.mySquad.length) {
                    // Allow less than 11 if squad is small in demo
                    if(auctionSystem.mySquad.length >= 11 && this.playing11.length < 11) {
                        alert("Please select 11 players.");
                        return;
                    }
                }
                if(this.playing11.length === 0) {
                    // Auto select top 11
                    this.playing11 = auctionSystem.mySquad.slice(0, 11).map((_, i) => i);
                }
                
                // Map indices to player objects for the match
                this.matchSquad = this.playing11.map(i => auctionSystem.mySquad[i]);
                this.battedPlayers = [];
                
                // Proceed to Toss
                this.startToss();
            }

            startToss() {
                this.showScreen('toss-screen');
                const userTeamName = TEAMS.find(t=>t.id===this.userTeamId).name;
                document.getElementById('toss-match-title').innerText = `${userTeamName} vs ${this.currentOpponent.name}`;
                document.getElementById('toss-coin-section').style.display = 'block';
                document.getElementById('toss-decision-section').style.display = 'none';
            }

            tossCoin(call) {
                const outcomes = ['Heads', 'Tails'];
                const result = outcomes[Math.floor(Math.random() * 2)];
                
                document.getElementById('toss-coin-section').style.display = 'none';
                document.getElementById('toss-decision-section').style.display = 'block';
                const resText = document.getElementById('toss-result-text');
                
                if(call === result) {
                    resText.innerText = `${result}! You Won the Toss.`;
                    document.getElementById('user-decision-buttons').style.display = 'block';
                    document.getElementById('ai-decision-text').style.display = 'none';
                } else {
                    resText.innerText = `${result}! ${this.currentOpponent.name} Won.`;
                    document.getElementById('user-decision-buttons').style.display = 'none';
                    document.getElementById('ai-decision-text').style.display = 'block';
                    
                    // AI Decision
                    const aiBat = Math.random() > 0.5;
                    const decision = aiBat ? "Bat" : "Bowl";
                    document.getElementById('ai-decision-msg').innerText = `${this.currentOpponent.name} elected to ${decision} first.`;
                    
                    // If AI Bats, User Bowls. Target is null initially (set after 1st innings).
                    this.target = null;
                    this.playerRole = aiBat ? 'bowling' : 'batting';
                }
            }

            setDecision(choice) {
                this.target = null;
                this.playerRole = (choice === 'bat') ? 'batting' : 'bowling';
                this.startMatchFromToss();
            }

            startMatchFromToss() {
                // If batting, select openers. If bowling, start match directly (AI bats).
                // For this user request, we focus on batting selection.
                if(this.playerRole === 'batting' || !this.playerRole) { // Default to batting if undefined
                    this.showBatsmanSelector('openers');
                } else {
                    this.showBowlerSelector();
                }
            }

            showBatsmanSelector(mode) {
                this.showScreen('batsman-select-screen');
                const list = document.getElementById('bat-select-list');
                list.innerHTML = '';
                this.selectionMode = mode; // 'openers' or 'next'
                this.tempSelection = [];

                document.getElementById('batsman-select-title').innerText = (mode === 'openers') ? "Select Opening Pair" : "Select Next Batsman";
                document.getElementById('selection-instruction').innerText = (mode === 'openers') ? "Select Striker" : "Select Incoming Batsman";
                document.getElementById('current-selection-display').innerText = "None";

                this.matchSquad.forEach((p, i) => {
                    // Filter out players who are already out or playing
                    if(!this.battedPlayers.includes(i)) {
                        const btn = document.createElement('button');
                        btn.className = 'btn btn-secondary';
                        btn.style.textAlign = 'left';
                        btn.innerHTML = `${p.name} <span style="float:right; color:gold;">${p.role}</span>`;
                        btn.onclick = () => this.handlePlayerSelect(i, p.name);
                        list.appendChild(btn);
                    }
                });
            }

            handlePlayerSelect(index, name) {
                if(this.selectionMode === 'openers') {
                    if(this.tempSelection.length === 0) {
                        this.tempSelection.push(index);
                        document.getElementById('current-selection-display').innerText = `Striker: ${name}`;
                        document.getElementById('selection-instruction').innerText = "Select Non-Striker";
                    } else if (this.tempSelection.length === 1) {
                        if(this.tempSelection[0] === index) return;
                        this.tempSelection.push(index);
                        document.getElementById('current-selection-display').innerText += `\nNon-Striker: ${name}`;
                    }
                } else {
                    // Next batsman
                    this.tempSelection = [index];
                    document.getElementById('current-selection-display').innerText = `Incoming: ${name}`;
                }
            }

            confirmBatsmanSelection() {
                if(this.selectionMode === 'openers') {
                    if(this.tempSelection.length < 2) { alert("Select 2 players!"); return; }
                    
                    this.currentBatsman = this.matchSquad[this.tempSelection[0]];
                    this.currentNonStriker = this.matchSquad[this.tempSelection[1]];
                    
                    this.currentBatsman.matchRuns = 0;
                    this.currentBatsman.matchBalls = 0;
                    this.currentNonStriker.matchRuns = 0;
                    this.currentNonStriker.matchBalls = 0;
                    
                    this.battedPlayers.push(this.tempSelection[0]);
                    this.battedPlayers.push(this.tempSelection[1]);
                    
                    this.initiateMatchSequence();
                } else {
                    if(this.tempSelection.length < 1) { alert("Select a player!"); return; }
                    
                    this.currentBatsman = this.matchSquad[this.tempSelection[0]];
                    this.battedPlayers.push(this.tempSelection[0]);
                    this.currentBatsman.matchRuns = 0;
                    this.currentBatsman.matchBalls = 0;
                    
                    // Resume Game
                    this.showScreen(''); // Hide screens
                    document.getElementById('hud').style.display = 'block';
                    if(this.bowlerInterval) clearInterval(this.bowlerInterval);
                    this.shotPlayed = false;
                    this.ballActive = false;
                    this.game3D.setupMatchScene(); // Re-render players
                    this.updateScoreboard();
                    this.startBowlingLoop();
                }
            }

            showBowlerSelector() {
                this.showScreen('bowler-select-screen');
                const list = document.getElementById('bowl-select-list');
                list.innerHTML = '';
                this.tempSelection = [];
                document.getElementById('current-bowler-display').innerText = "None";

                // Bowling quota rules
                let maxOversPerBowler;
                if (this.matchOvers <= 5) {
                    maxOversPerBowler = 1;
                } else if (this.matchOvers <= 10) {
                    maxOversPerBowler = 2;
                } else { // 20 overs
                    maxOversPerBowler = 4;
                }

                this.matchSquad.forEach((p, i) => {
                    if(p.role === 'Bowler' || p.role === 'All-Rounder') {
                        const oversBowled = Math.floor((p.matchBallsBowled || 0) / 6);
                        const canBowl = oversBowled < maxOversPerBowler;

                        const btn = document.createElement('button');
                        btn.className = 'btn btn-secondary';
                        btn.style.textAlign = 'left';
                        
                        const oversDisplay = `${oversBowled}/${maxOversPerBowler}`;
                        btn.innerHTML = `${p.name} <span style="float:right; color:gold;">${p.role} (${oversDisplay} ov)</span>`;
                        
                        if (canBowl) {
                            btn.onclick = () => {
                                this.tempSelection = [i];
                                document.getElementById('current-bowler-display').innerText = p.name;
                            };
                        } else {
                            btn.disabled = true;
                            btn.style.opacity = 0.5;
                            btn.style.cursor = 'not-allowed';
                        }
                        list.appendChild(btn);
                    }
                });
            }

            confirmBowlerSelection() {
                if(this.tempSelection.length < 1) { alert("Select a bowler!"); return; }
                this.currentBowler = this.matchSquad[this.tempSelection[0]];
                
                if(this.currentBowler.matchWickets === undefined) this.currentBowler.matchWickets = 0;
                if(this.currentBowler.matchRunsConceded === undefined) this.currentBowler.matchRunsConceded = 0;
                if(this.currentBowler.matchBallsBowled === undefined) this.currentBowler.matchBallsBowled = 0;

                // --- NEW: Set bowling type based on ability ---
                if (this.currentBowler.bowlingStyle) {
                    this.bowlingType = this.currentBowler.bowlingStyle;
                    this.showCommentary(`Selected: ${this.currentBowler.name} (${this.bowlingType})`, false);
                }

                // Update UI for Fast Bowler
                const controlsUI = document.getElementById('bowling-controls-ui');
                if (controlsUI) {
                    if (this.playerRole === 'bowling' && this.bowlingType === 'Fast') {
                        controlsUI.style.display = 'flex';
                    } else {
                        controlsUI.style.display = 'none';
                    }
                }

                if(!this.isGameActive) {
                    this.initiateMatchSequence();
                } else {
                    this.showScreen('');
                    document.getElementById('hud').style.display = 'block';
                    if(this.playerRole === 'bowling') this.showCommentary("Press Space to Bowl", false);
                }
            }

            selectNextAIBowler() {
                let maxOversPerBowler;
                if (this.matchOvers <= 5) {
                    maxOversPerBowler = 1;
                } else if (this.matchOvers <= 10) {
                    maxOversPerBowler = 2;
                } else { // 20 overs
                    maxOversPerBowler = 4;
                }

                const availableBowlers = this.aiBowlingLineup.filter(p => {
                    const oversBowled = Math.floor((p.matchBallsBowled || 0) / 6);
                    return oversBowled < maxOversPerBowler && p.name !== this.currentBowler.name;
                });

                if (availableBowlers.length > 0) {
                    return availableBowlers[Math.floor(Math.random() * availableBowlers.length)];
                } else {
                    // If all others are used, check if any bowler (including current) has quota left
                    const allAvailable = this.aiBowlingLineup.filter(p => {
                        const oversBowled = Math.floor((p.matchBallsBowled || 0) / 6);
                        return oversBowled < maxOversPerBowler;
                    });
                    if (allAvailable.length > 0) {
                        return allAvailable[Math.floor(Math.random() * allAvailable.length)];
                    }
                }
                // Fallback if no one is available
                console.warn("No available AI bowlers with quota. Re-using a random one.");
                return this.aiBowlingLineup[Math.floor(Math.random() * this.aiBowlingLineup.length)];
            }

            initiateMatchSequence() {
                this.goFullscreenAndLockOrientation().then(() => {
                    // Hide UI screens
                    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                    
                    this.game3D.startIntroAnimation(() => {
                        this.startMatchCountdown();
                    });
                });
            }

            startMatchCountdown() {
                const countdownElement = document.getElementById('countdown-overlay');
                if(countdownElement) {
                    countdownElement.style.display = 'flex';
                    let count = 5;
                    countdownElement.innerText = count;

                    const interval = setInterval(() => {
                        count--;
                        if (count > 0) {
                            countdownElement.innerText = count;
                        } else if (count === 0) {
                            countdownElement.innerText = "PLAY!";
                        } else {
                            clearInterval(interval);
                            countdownElement.style.display = 'none';
                            this.startMatch(); 
                        }
                    }, 1000);
                } else {
                    this.startMatch();
                }
            }

            startMatch() {
                this.isGameActive = true;
                this.game3D.animationState = 'match'; // Start game loop
                
                // FORCE CAMERA RESET: Ensure camera snaps to player view immediately
                this.game3D.camera.position.set(0, 5, -22);
                this.game3D.camera.lookAt(0, 1, -10);

                this.playerRole = this.playerRole || 'batting'; // Use role set during toss/practice setup
                this.target = this.target || null; // Use target set during innings break
                this.runs = 0;
                this.wickets = 0;
                this.ballsBowled = 0;
                this.matchOvers = this.isPracticeMode ? 1000 : (parseInt(document.getElementById('overs-select').value) || 2);
                const isNight = document.getElementById('time-select').value === 'night';

                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                document.getElementById('hud').style.display = 'block';
                document.getElementById('controls-hint').style.display = 'block';
                document.getElementById('field-btn').style.display = (this.playerRole === 'bowling') ? 'block' : 'none';
                
                // Update Mobile Buttons Text based on Role
                const loftBtn = document.getElementById('btn-loft');
                if(loftBtn) loftBtn.innerText = (this.playerRole === 'bowling') ? "BOWL" : "HIT";
                if(document.getElementById('btn-ground')) document.getElementById('btn-ground').style.display = (this.playerRole === 'bowling') ? 'none' : 'flex';
                const groundBtn = document.getElementById('btn-ground');
                const fastBtn = document.getElementById('btn-fast-bowl');
                const spinBtn = document.getElementById('btn-spin-bowl');

                if (this.playerRole === 'bowling') {
                    if(loftBtn) loftBtn.innerText = "BOWL";
                    if(groundBtn) groundBtn.style.display = 'none';
                    if(fastBtn) fastBtn.style.display = 'none';
                    if(spinBtn) spinBtn.style.display = 'none';
                } else {
                    if(loftBtn) loftBtn.innerText = "HIT";
                    if(groundBtn) groundBtn.style.display = 'flex';
                    if(fastBtn) fastBtn.style.display = 'none';
                    if(spinBtn) spinBtn.style.display = 'none';
                }

                // Update UI for Fast Bowler Variations
                const controlsUI = document.getElementById('bowling-controls-ui');
                if (controlsUI) {
                    if (this.playerRole === 'bowling' && this.bowlingType === 'Fast') {
                        controlsUI.style.display = 'flex';
                    } else {
                        controlsUI.style.display = 'none';
                    }
                }
                
                if(this.playerRole === 'bowling') {
                    // Setup dummy AI batsmen if user is bowling
                    this.currentBatsman = { name: "AI Rohit", power: 80, jerseyNumber: 45 };
                    this.currentNonStriker = { name: "AI Virat", power: 80, jerseyNumber: 18 };
                    this.showCommentary("Press BOWL to start", false);
                    document.getElementById('bowling-controls').style.display = 'block';
                } else {
                    // --- MODIFIED: Use real players for AI bowling lineup ---
                    this.aiBowlingLineup = PLAYERS_2025.filter(p => p.role === 'Bowler' || p.role === 'All-Rounder').slice(0, 5);
                    if (this.aiBowlingLineup.length < 5) {
                        // Fallback if not enough bowlers in the main list
                        this.aiBowlingLineup.push(...PLAYERS_2025.slice(0, 5 - this.aiBowlingLineup.length));
                    }
                    // Reset their match stats for the current game
                    this.aiBowlingLineup.forEach(p => {
                        p.matchWickets = 0;
                        p.matchRunsConceded = 0;
                        p.matchBallsBowled = 0;
                    });

                    // Select first AI bowler
                    if (!this.currentBowler) this.currentBowler = this.aiBowlingLineup[0];
                    document.getElementById('bowling-controls').style.display = 'none';
                }

                const userTeamName = TEAMS.find(t=>t.id===this.userTeamId).name;
                document.getElementById('match-teams').innerText = `${userTeamName} vs ${this.currentOpponent.name}`;
                
                let statusText = this.target ? `Target: ${this.target}` : "1st Innings";
                if(this.tournamentStage === 'semi-final') statusText += " (SF)";
                if(this.tournamentStage === 'final') statusText += " (FINAL)";
                if(this.isSuperOver) statusText = "SUPER OVER!";
                
                document.getElementById('match-status').innerText = statusText;
                if(this.isPracticeMode) document.getElementById('match-status').innerText = "Practice Mode";
                if(this.isTargetMode) {
                    document.getElementById('match-status').innerText = "Target Practice";
                    this.game3D.createTargets();
                } else {
                    this.game3D.clearTargets();
                }
                
                this.updateScoreboard();
                this.game3D.setDayNightMode(isNight);
                this.game3D.setupMatchScene();
                this.soundManager.playCrowdLoop();
                this.startBowlingLoop();
            }

            updateScoreboard() {
                if(this.isTargetMode) {
                    document.querySelector('.score-main').innerHTML = `Pts: ${this.targetScore} | Balls: ${this.targetBalls}`;
                    document.getElementById('score-overs').innerText = "Hit the targets!";
                    return;
                }
                
                // Restore standard scoreboard if needed
                if(!document.getElementById('score-runs')) {
                    document.querySelector('.score-main').innerHTML = `<span id="score-runs">0</span> - <span id="score-wickets">0</span>`;
                }

                document.getElementById('score-runs').innerText = this.runs;
                document.getElementById('score-wickets').innerText = this.wickets;
                const overs = Math.floor(this.ballsBowled / 6) + "." + (this.ballsBowled % 6);
                document.getElementById('score-overs').innerText = `${overs} / ${this.matchOvers}`;
                
                if(this.currentBatsman) {
                    document.getElementById('striker-name').innerText = `${this.currentBatsman.name} ${this.currentBatsman.matchRuns || 0}(${this.currentBatsman.matchBalls || 0}) *`;
                    document.getElementById('non-striker-name').innerText = this.currentNonStriker ? `${this.currentNonStriker.name} ${this.currentNonStriker.matchRuns || 0}(${this.currentNonStriker.matchBalls || 0})` : "";
                }
                
                if(this.currentBowler) {
                    const bOvers = Math.floor((this.currentBowler.matchBallsBowled || 0) / 6) + "." + ((this.currentBowler.matchBallsBowled || 0) % 6);
                    document.getElementById('bowler-name').innerText = `${this.currentBowler.name}: ${this.currentBowler.matchWickets || 0}-${this.currentBowler.matchRunsConceded || 0} (${bOvers})`;
                }
            }

            setupControls() {
                window.addEventListener('keyup', (e) => {
                    this.activeKeys[e.key] = false;
                    this.activeKeys[e.code] = false; // Also clear by code
                });
                window.addEventListener('keydown', (e) => {
                    // Prevent default browser action for game keys
                    if(['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyA', 'KeyD', 'KeyW', 'KeyS', 'KeyZ', 'KeyX'].includes(e.code)) {
                        e.preventDefault();
                    }

                    this.activeKeys[e.key] = true;
                    this.activeKeys[e.code] = true; // Also store by code for consistency

                    if(!this.isGameActive || this.isPaused) return;

                    // Handle single-press actions (ignore repeats from holding key down)
                    if (e.repeat) return;

                    if (e.code === 'Space') {
                        if (this.playerRole === 'batting') {
                            this.swingBat('lofted');
                        } else { // Bowling
                            this.handleBowlingAction();
                        }
                    } else if (this.playerRole === 'batting') {
                        if(e.code === 'KeyZ') this.swingBat('defensive');
                        if(e.code === 'KeyX') this.swingBat('lofted');
                    }
                });
            }

            setupTouchControls() {
                const gameContainer = document.getElementById('game-container');
                const btnLeft = document.getElementById('btn-left');
                const btnRight = document.getElementById('btn-right');
                const btnLoft = document.getElementById('btn-loft'); // Acts as HIT or BOWL
                const btnGround = document.getElementById('btn-ground');

            
                const setKey = (key, active) => { this.activeKeys[key] = active; };

            
                // Movement (Left/Right)
                if(btnLeft) {
                    btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); setKey('a', true); setKey('ArrowLeft', true); });
                    btnLeft.addEventListener('touchend', (e) => { e.preventDefault(); setKey('a', false); setKey('ArrowLeft', false); });
                }
                if(btnRight) {
                    btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); setKey('d', true); setKey('ArrowRight', true); });
                    btnRight.addEventListener('touchend', (e) => { e.preventDefault(); setKey('d', false); setKey('ArrowRight', false); });
                }

            
                // Actions
                if(btnLoft) {
                    btnLoft.addEventListener('touchstart', (e) => { 
                        console.log("Touchstart on Loft/Hit button"); // Log touch events
                        e.preventDefault(); 
                        if(this.playerRole === 'batting') {
                            this.swingBat('lofted'); 
                        } else if (this.playerRole === 'bowling') {
                            this.handleBowlingAction();
                        }
                    });
                }
                if(btnGround) {
                    btnGround.addEventListener('touchstart', (e) => { 
                        console.log("Touchstart on Ground/Defensive button"); // Log touch events
                        e.preventDefault(); 
                        if(this.playerRole === 'batting') this.swingBat('defensive'); 
                    });
                }

                // --- New Swipe Aiming Logic for Mobile Bowling ---
            
                if (gameContainer) {
                    gameContainer.addEventListener('touchstart', (e) => {
                        if (this.isPaused || e.touches.length !== 1 || e.target.classList.contains('control-btn')) return;

                        if (this.playerRole === 'bowling' && this.bowlingState === 'aiming') {
                            e.preventDefault();
                            this.isSwiping = true;
                            this.touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                            this.initialAimPos = this.bowlingAim.clone();
                        } else if (this.isGameActive && this.playerRole === 'batting') {
                            e.preventDefault();
                            this.isSwiping = true; // Use same flag for consistency
                            this.touchStartX = e.touches[0].clientX;
                        }
                    }, { passive: false });

            
                    gameContainer.addEventListener('touchmove', (e) => {
                        if (!this.isSwiping || this.isPaused || e.touches.length !== 1) return;

                        if (this.playerRole === 'bowling' && this.bowlingState === 'aiming' && this.initialAimPos) {
                            e.preventDefault();
                            const touchCurrentPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                            const deltaX = touchCurrentPos.x - this.touchStartPos.x;
                            const deltaY = touchCurrentPos.y - this.touchStartPos.y;
                            this.bowlingAim.x = this.initialAimPos.x + (deltaX * 0.015);
                            this.bowlingAim.z = this.initialAimPos.z + (deltaY * 0.025);
                        } else if (this.isSwiping && this.isGameActive && this.playerRole === 'batting') {
                            e.preventDefault();
                            const movementSensitivity = 0.005;
                            const currentTouchX = e.touches[0].clientX;
                            const diffX = currentTouchX - this.touchStartX;
            
                            if (this.game3D && this.game3D.batsmanGroup) {
                                let newX = this.game3D.batsmanGroup.position.x + (diffX * movementSensitivity);
                                newX = THREE.MathUtils.clamp(newX, -1.5, 1.5);
                                this.game3D.batsmanGroup.position.x = newX;
                            }
                            this.touchStartX = currentTouchX;
                        }
                    }, { passive: false });

            
                    gameContainer.addEventListener('touchend', (e) => {
                        if (!this.isSwiping) return;
                        this.isSwiping = false;
                        this.initialAimPos = null;
                        this.touchStartX = 0;
                    }, { passive: false });
                }
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                const btn = document.getElementById('pause-btn');
                btn.innerText = this.isPaused ? "‚ñ∂" : "II";
            }

            exitMatch() {
                if(!confirm("Exit to Main Menu?")) return;

                // 1. Reset all core game state variables
                this.isGameActive = false;
                this.ballActive = false;
                this.isPaused = false;
                this.isPracticeMode = false;
                this.isTargetMode = false;
                this.isRunning = false;
                this.shotPlayed = false;
                this.bowlingState = 'idle';

                // 2. Clear any running timers and stop all sounds
                if(this.bowlerInterval) clearInterval(this.bowlerInterval);
                this.bowlerInterval = null;
                this.soundManager.stopAllSounds();
                this.soundManager.stopCrowdLoop();

                // 3. Clean up the 3D scene to remove all match objects
                const g3d = this.game3D;
                g3d.clearTargets();
                g3d.resetTrail();
                if (g3d.batsmanGroup) { g3d.scene.remove(g3d.batsmanGroup); g3d.batsmanGroup = null; }
                if (g3d.bowlerGroup) { g3d.scene.remove(g3d.bowlerGroup); g3d.bowlerGroup = null; }
                if (g3d.nonStrikerGroup) { g3d.scene.remove(g3d.nonStrikerGroup); g3d.nonStrikerGroup = null; }
                if (g3d.umpire) { g3d.scene.remove(g3d.umpire); g3d.umpire = null; }
                g3d.fielders.forEach(f => g3d.scene.remove(f)); g3d.fielders = [];

                // 4. Hide all in-game UI and show the main menu
                document.getElementById('hud').style.display = 'none';
                document.getElementById('controls-hint').style.display = 'none';
                document.getElementById('speedometer').style.display = 'none';
                document.getElementById('field-btn').style.display = 'none';
                const controlsUI = document.getElementById('bowling-controls-ui');
                if(controlsUI) controlsUI.style.display = 'none';
                this.showScreen('menu-screen');
            }

            handleBowlingAction() {
                if (this.ballActive || this.isRunning) return;

                if (this.bowlingState === 'idle') {
                    this.bowlingState = 'power';
                    this.bowlingPower = 0;
                    document.getElementById('speedometer').style.display = 'block';
                    this.showCommentary("Tap to set Power", false);
                } else if (this.bowlingState === 'power') {
                    this.bowlingState = 'aiming';
                    document.getElementById('speedometer').style.display = 'none';
                    this.game3D.pitchMarker.visible = true;
                    this.game3D.pitchMarker.position.copy(this.bowlingAim);
                    this.showCommentary("Aim and Tap to Bowl", false);
                } else if (this.bowlingState === 'aiming') {
                    this.bowlingState = 'idle';
                    this.game3D.pitchMarker.visible = false;
                    this.deliverManualBall();
                }
            }

            startBowlingLoop() {
                // Don't start AI bowling if user is bowling or if the match is over.
                if(this.playerRole === 'bowling' || !this.isGameActive) return;
                
                if(this.bowlerInterval) clearInterval(this.bowlerInterval);
                this.ballActive = false;
                this.shotPlayed = false;
                
                // AI bowls immediately without run-up for faster gameplay
                this.deliverBall();
            }

            deliverManualBall() {
                this.isWide = false;
                this.isNoBall = false;
                this.isPotentialCatch = false;
                this.shotPlayed = false;
                this.game3D.resetTrail();
                
                this.isFreeHit = this.pendingFreeHit;
                this.pendingFreeHit = this.isFreeHit; // Maintain status for Wides
                if(this.isFreeHit) this.showCommentary("FREE HIT!", true);

                const ball = this.game3D.ball;
                ball.visible = true;
                const releasePos = new THREE.Vector3(this.game3D.bowlerGroup.position.x, 2, 8);
                ball.position.copy(releasePos);
                this.ballActive = true;
                
                let speed = -0.4; // Medium
                if(this.bowlingType === 'Fast') speed = -0.6;
                if(this.bowlingType === 'Spin') speed = -0.25;
                // Calculate velocity to hit the target
                const aimPos = this.bowlingAim.clone();
                const gravity = 0.016; // 2 * 0.008
                const minSpeed = -0.4;
                const maxSpeed = -0.7;
                const vz = minSpeed + (this.bowlingPower * (maxSpeed - minSpeed));
                const t = (aimPos.z - releasePos.z) / vz;
                
                if (this.bowlingType === 'Fast' && this.bowlingVariation === 'Slower') {
                    this.ballVelocity.z = vz * 0.6; // Apply slower ball speed
                }

                if (t <= 0) {
                    console.error("Invalid aim position");
                    this.ballVelocity.set(0, 0, -0.5); // Default bowl
                } else {
                    const vx = (aimPos.x - releasePos.x) / t;
                    const my_vy = (0.004 * t * t - 2) / t;
                    
                    // Apply slower ball to calculated velocity
                    if (this.bowlingType === 'Fast' && this.bowlingVariation === 'Slower') {
                        this.ballVelocity.set(vx * 0.8, my_vy, vz * 0.6);
                    } else {
                        this.ballVelocity.set(vx, my_vy, vz);
                    }
                }
                
                let spinX = 0;
                if(this.bowlingType === 'Spin') spinX = (Math.random() - 0.5) * 0.02; // Reduced sideways spin
                if(this.bowlingType === 'Fast') {
                    if (this.bowlingVariation === 'InSwing') spinX = -0.015;
                    if (this.bowlingVariation === 'OutSwing') spinX = 0.015;
                }

                this.isUserCurrentlyBowling = true;
                this.currentSpinX = spinX;
            }

            deliverBall() {
                this.isWide = false;
                this.isNoBall = false;
                this.isPotentialCatch = false;
                this.game3D.resetTrail();
                
                this.isFreeHit = this.pendingFreeHit;
                this.pendingFreeHit = this.isFreeHit; // Maintain status for Wides
                if(this.isFreeHit) this.showCommentary("FREE HIT!", true);

                // Random No Ball Chance (5%)
                if(!this.isPracticeMode && Math.random() < 0.05) {
                    this.isNoBall = true;
                    this.runs += 1;
                    this.soundManager.playSound('umpireNoBall');
                    if(this.currentBowler) this.currentBowler.matchRunsConceded += 1;
                    this.showCommentary("NO BALL! (+1 Run)", true);
                    this.pendingFreeHit = true; // Next ball is Free Hit
                }

                const ball = this.game3D.ball;
                ball.visible = true;
                ball.position.set(0, 2, 8); // Release point
                this.ballActive = true;
                const xSpread = (this.isPracticeMode || this.isTargetMode) ? 0.05 : 0.046; // Reduced spread to lower wide chance to ~20%
                const vx = (Math.random() - 0.5) * xSpread;
                
                // --- NEW: Use Bowler's Ability ---
                let vz = -0.45 - (Math.random() * 0.1); // Default medium pace
                let spinX = 0;
                if (this.currentBowler && this.currentBowler.bowlingStyle) {
                    if (this.currentBowler.bowlingStyle === 'Fast') {
                        vz = -0.55 - (Math.random() * 0.2); // -0.55 to -0.75 (Faster)
                        
                        // AI Variations
                        const rand = Math.random();
                        if (rand < 0.2) { // 20% Slower
                            vz *= 0.6;
                            this.showCommentary("Slower Ball", false);
                        } else if (rand < 0.4) { // 20% In Swing
                            spinX = -0.015;
                        } else if (rand < 0.6) { // 20% Out Swing
                            spinX = 0.015;
                        }
                    } else if (this.currentBowler.bowlingStyle === 'Spin') {
                        vz = -0.3 - (Math.random() * 0.1); // -0.3 to -0.4 (Slower)
                        spinX = (Math.random() - 0.5) * 0.03; // Add spin
                    }
                }
                this.ballVelocity.set(vx, 0, vz);
                this.currentSpinX = spinX; // Store spin for physics loop

                // Predict Landing Spot for Marker
                // y = 2, vy = 0, g = 0.008. 0 = 2 - 0.004t^2 => t = 22.36 frames
                const t = 22.36;
                const landX = 0 + vx * t;
                const landZ = 8 + vz * t;
                
                this.game3D.pitchMarker.position.set(landX, 0.05, landZ);
                this.game3D.pitchMarker.visible = true;

                this.isUserCurrentlyBowling = false;
                this.currentSpinX = 0;
            }

            updateBallPhysics() {
                if (this.isPaused || !this.ballActive) return;

                const ball = this.game3D.ball;
                if (!ball) return;

                ball.position.add(this.ballVelocity);
                // --- MODIFIED: Apply Spin (for both AI and User) ---
                if (!this.shotPlayed && this.currentSpinX !== 0) {
                    ball.position.x += this.currentSpinX;
                }
                // --- NEW Fielder Interaction Logic ---
                if (this.shotPlayed) {
                    for (let i = 0; i < this.game3D.fielders.length; i++) {
                        const fielder = this.game3D.fielders[i];
                        if (fielder.userData.isAnimating) continue; // Skip fielders already in an animation

                        const distToFielder = ball.position.distanceTo(fielder.position);

                        // Check for catch or stop within the fielder's reach
                        if (distToFielder < 1.5) { 
                            // CATCH LOGIC: Ball is in the air, coming down, and was a potential catch
                            if (this.isPotentialCatch && ball.position.y > 0.5 && ball.position.y < 2.5 && this.ballVelocity.y < 0) {
                                if (this.isNoBall || this.isFreeHit) { // NOT OUT
                                    this.soundManager.playSound('umpireNotOut');
                                    this.showCommentary("CAUGHT, BUT NOT OUT!", true);
                                    this.isPotentialCatch = false; // Chance missed
                                    this.ballVelocity.y *= -0.5; // Drop the ball
                                } else { // OUT
                                    this.wickets++;
                                    if(this.currentBowler) this.currentBowler.matchWickets++;
                                    this.soundManager.playSound('umpireOut');
                                    this.showCommentary("CAUGHT!", true);
                                    this.isReplayActive = true;
                                    this.soundManager.playSound('caught');
                                    this.soundManager.playCheer();

                                    // --- NEW CATCH ANIMATION ---
                                    this.game3D.triggerFielderAnimation(fielder, 'catch');

                                    if(this.isPracticeMode || this.isTargetMode) {
                                        this.wickets--; // Don't count wicket in practice
                                        this.ballActive = false;
                                        this.game3D.ball.visible = false;
                                        setTimeout(() => {
                                            this.showCommentary("Practice: Not Out", false);
                                            this.completeDelivery();
                                        }, 2000);
                                        return; // Exit physics loop
                                    }

                                    this.ballActive = false;
                                    this.game3D.ball.visible = false;

                                    if(!this.isNoBall && !this.isWide) { this.ballsBowled++; if(this.currentBowler) this.currentBowler.matchBallsBowled++; }
                                    this.updateScoreboard();
                                    const overEnd = this.checkOverStatus();
                                    if(this.ballsBowled >= this.matchOvers * 6) { setTimeout(() => this.endMatch(), 10000); return; }
                                    setTimeout(() => { if(this.wickets < 10 && this.battedPlayers.length < 11) { this.showBatsmanSelector('next'); } else { this.endMatch(); } }, 10000);
                                    return; // Exit physics loop
                                }
                            } else if (ball.position.y < 0.5) { // GROUND FIELDING LOGIC: Ball is on the ground
                                this.ballVelocity.multiplyScalar(0.1); // Drastically slow down the ball
                                this.showCommentary("Stopped well!", false);
                                this.shotPlayed = false; // Prevent this from triggering again for this delivery
                            }
                        }
                        // --- NEW DIVE LOGIC ---
                        // Ball is on the ground, moving fast, and just about to pass the fielder.
                        else if (!this.isPotentialCatch && ball.position.y < 0.8 && this.ballVelocity.length() > 0.3 && distToFielder > 1.5 && distToFielder < 4.0) {
                            const ballToFielder = new THREE.Vector3().subVectors(fielder.position, ball.position).normalize();
                            const ballDirection = this.ballVelocity.clone().normalize();
                            const dot = ballToFielder.dot(ballDirection);

                            // If dot is close to 0, it's moving sideways relative to the fielder. A good time to dive.
                            // Also check if the fielder is generally behind the ball, so they dive forward.
                            if (Math.abs(dot) < 0.4 && fielder.position.z < ball.position.z) {
                                this.game3D.triggerFielderAnimation(fielder, 'dive', ball.position);
                                this.ballVelocity.multiplyScalar(0.1); // Dive stops the ball
                                this.showCommentary("GREAT DIVE!", true);
                                this.shotPlayed = false; // Prevent re-triggering
                                break; // Only one fielder should dive
                            }
                        }
                    }
                }

                // Air Resistance / Ground Friction
                this.ballVelocity.multiplyScalar(0.995);

                // Bounce logic
                if (ball.position.y <= 0) {
                    ball.position.y = 0;
                    this.game3D.pitchMarker.visible = false; // Hide marker on bounce

                    if (this.shotPlayed) {
                        // Dampen bounce for shots so they settle
                        this.ballVelocity.y = Math.abs(this.ballVelocity.y) * 0.5;
                        if (this.ballVelocity.y < 0.05) this.ballVelocity.y = 0;
                        this.ballVelocity.x *= 0.9; // Stronger friction for ground shots
                        this.ballVelocity.z *= 0.9;
                    } else {
                        this.ballVelocity.y = 0.15; // Standard bowling bounce
                        this.ballVelocity.x *= 0.95;
                        this.ballVelocity.z *= 0.95;
                    }
                } else {
                    this.ballVelocity.y -= 0.008; // Gravity
                }

                // AI Batting Check (If user is bowling)
                if (this.isUserCurrentlyBowling && ball.position.z < -8 && ball.position.z > -11 && !this.shotPlayed) {
                    this.aiBat();
                }

                // Check if ball stopped (Friction) OR passed batsman/boundary
                const isStopped = this.ballVelocity.length() < 0.1 && ball.position.y <= 0.1;

                // Target Mode Collision
                if (this.isTargetMode && !isStopped && this.shotPlayed) {
                    this.game3D.targets.forEach(t => {
                        if (t.visible && ball.position.distanceTo(t.position) < 3.0) {
                            t.visible = false;
                            this.targetScore += 10;
                            this.showCommentary("+10 POINTS!", true);
                            this.soundManager.playBatHit();
                            setTimeout(() => t.visible = true, 2000);
                        }
                    });
                }

                // User Bowled Check (When User is Batting)
                if (!this.isUserCurrentlyBowling && !this.shotPlayed && ball.position.z < -11 && ball.position.z > -11.5) {
                    if (Math.abs(ball.position.x) < 0.15) { // Hit stumps
                        if (this.isNoBall || this.isFreeHit) {
                            this.showCommentary("NOT OUT (" + (this.isNoBall ? "No Ball" : "Free Hit") + ")", true);
                            this.completeDelivery();
                            return;
                        }
                        this.wickets++;
                        this.soundManager.playSound('umpireOut');
                        if (this.currentBowler) this.currentBowler.matchWickets++;
                        this.showCommentary("BOWLED!", true);
                        this.isReplayActive = true;
                        this.soundManager.playSound('wicket'); // Play Wicket Sound
                        this.ballActive = false;
                        this.game3D.ball.visible = false;

                        if (this.isPracticeMode || this.isTargetMode) {
                            this.wickets--; // Don't count wicket
                            setTimeout(() => {
                                this.showCommentary("Practice: Not Out", false);
                                this.ballActive = true;
                                this.completeDelivery();
                            }, 1000);
                            return;
                        }

                        if (!this.isNoBall && !this.isWide) {
                            this.ballsBowled++;
                            if (this.currentBowler) this.currentBowler.matchBallsBowled++;
                        }
                        this.updateScoreboard();

                        if (this.checkOverStatus()) {
                            if (this.playerRole !== 'bowling') setTimeout(() => this.startBowlingLoop(), 3000);
                            return;
                        }

                        if (this.ballsBowled >= this.matchOvers * 6) {
                            setTimeout(() => this.endMatch(), 10000); // Replay Delay
                            return;
                        }

                        setTimeout(() => {
                            if (this.wickets < 10 && this.battedPlayers.length < 11) {
                                this.showBatsmanSelector('next');
                            } else {
                                this.endMatch();
                            }
                        }, 10000); // Replay Delay
                        return;
                    }
                }

                // Wide Ball Check (When ball passes stumps)
                if (!this.isPracticeMode && !this.isTargetMode && ball.position.z < -11 && ball.position.z > -13 && !this.shotPlayed && !this.isWide) {
                    if (Math.abs(ball.position.x) > 0.7) { // 0.7 is approx wide line
                        this.isWide = true;
                        this.runs += 1;
                        this.soundManager.playSound('umpireWide');
                        if (this.currentBowler) this.currentBowler.matchRunsConceded += 1;
                        this.showCommentary("WIDE BALL! (+1 Run)", true);
                    }
                }

                const isOutOfBounds = ball.position.z < -12 || ball.position.z > 100 || Math.abs(ball.position.x) > 60;

                if (isOutOfBounds || isStopped) {
                    this.completeDelivery();
                }
            }

            onRunComplete() {
                this.isRunning = false;
                
                // If ball is still active (physics running), force complete it to count the ball
                if(this.ballActive) {
                    this.completeDelivery();
                }

                if(this.waitingForRun) {
                    this.waitingForRun = false;
                    setTimeout(() => this.startBowlingLoop(), 1000);
                }
                if(this.playerRole === 'bowling') {
                    // After a run, the ball is dead. Reset state to allow next delivery.
                    this.bowlingState = 'idle';
                    this.showCommentary("Press BOWL to start", false);
                }
            }

            checkOverStatus() {
                // Check if Over is Completed (and not Match End)
                if (this.ballsBowled % 6 === 0 && this.ballsBowled > 0 && this.ballsBowled < this.matchOvers * 6) {
                    // Swap Batsmen (Strike Rotation)
                    const temp = this.currentBatsman;
                    this.currentBatsman = this.currentNonStriker;
                    this.currentNonStriker = temp;
                    
                    if(this.playerRole === 'bowling') {
                        this.bowlingState = 'idle'; // Reset state
                        // User Bowling: Show Selector
                        this.isReplayActive = true;
                        setTimeout(() => this.showBowlerSelector(), 10000);
                        return true; // Over ended
                    } else {
                        // User Batting: Rotate AI Bowler
                        this.currentBowler = this.selectNextAIBowler();
                        // --- NEW: Use bowler's ability for commentary ---
                        const style = this.currentBowler.bowlingStyle ? `(${this.currentBowler.bowlingStyle})` : '';
                        this.showCommentary(`End of Over. New Bowler: ${this.currentBowler.name} ${style}`, false);
                        this.isReplayActive = true;
                        return true; // Over ended
                    }
                }
                return false; // Over continuing
            }

            completeDelivery() {
                if(!this.ballActive) return;
                this.ballActive = false;
                this.game3D.pitchMarker.visible = false;
                this.game3D.ball.visible = false;
                this.game3D.resetFielderPositions();
                
                let isOverEnded = false;
                const replayDelay = this.isReplayActive ? 10000 : 2000; // Check for replay
                this.isReplayActive = false; // Reset flag

                if(this.isTargetMode) {
                    this.targetBalls--;
                    this.updateScoreboard();
                    if(this.targetBalls <= 0) {
                        alert("Target Practice Over! Final Score: " + this.targetScore);
                        this.exitMatch();
                        return;
                    }
                }

                // Only count legal deliveries
                if(!this.isWide && !this.isNoBall) {
                    this.ballsBowled++;
                    this.pendingFreeHit = false; // Legal ball consumes Free Hit
                    if(this.currentBowler) this.currentBowler.matchBallsBowled++;
                    // If shot NOT played, increment ball count (Dot ball/Miss)
                    // If shot WAS played, it is incremented in swingBat/aiBat
                    if(!this.shotPlayed && this.currentBatsman) this.currentBatsman.matchBalls++;

                    // Check End of Over
                    isOverEnded = this.checkOverStatus();
                }

                this.updateScoreboard();
                
                if(this.ballsBowled >= this.matchOvers * 6) {
                    this.endMatch();
                    return;
                }

                if (isOverEnded) {
                    // Logic for over change is handled in checkOverStatus (bowler selector or AI loop restart)
                    if (this.playerRole !== 'bowling') {
                        setTimeout(() => this.startBowlingLoop(), replayDelay);
                    }
                } else {
                    // Over is not ended, prepare for next ball.
                    if (this.playerRole === 'bowling') {
                    if (this.isRunning) {
                        // Don't show "Press BOWL" yet, wait for run to complete.
                        this.showCommentary("Batsmen Running...", false);
                    } else {
                        // After a normal delivery, reset state and prompt user.
                        setTimeout(() => {
                            this.bowlingState = 'idle';
                            this.showCommentary("Press BOWL to start", false);
                        }, replayDelay);
                    }
                    } else { // User is batting
                        if (this.isRunning) {
                            // Ball is dead, but we are waiting for a run to complete.
                            // The onRunComplete callback will trigger the next bowling loop.
                            this.waitingForRun = true;
                        } else {
                            // Ball is dead, no run, start next AI delivery after a delay.
                            setTimeout(() => this.startBowlingLoop(), replayDelay);
                        }
                    }
                }
            }

            aiBat() {
                // Simple AI
                const hitChance = (this.bowlingType === 'Fast') ? 0.7 : 0.85;
                const isReachable = Math.abs(this.game3D.ball.position.x) < 1.0;

                if(Math.random() < hitChance && isReachable) {
                    this.shotPlayed = true;
                    this.soundManager.playBatHit();
                    if(!this.isNoBall && this.currentBatsman) this.currentBatsman.matchBalls++;
                    
                    // AI Bat Swing Animation
                    const bat = this.game3D.batsmanGroup.userData.bat;
                    if(bat && this.game3D.batsmanGroup) {
                        bat.rotation.x = -1.5;
                        this.game3D.batsmanGroup.rotation.y = 1.2;
                        setTimeout(() => { 
                            if(bat) bat.rotation.x = 0.5; 
                            if(this.game3D.batsmanGroup) this.game3D.batsmanGroup.rotation.y = 0;
                        }, 300);
                    }

                    // AI Shot Logic
                    const shotOutcome = Math.random();
                    if (shotOutcome > 0.8) { // 20% chance of a six
                        this.ballVelocity.z = 0.8; 
                        this.ballVelocity.y = 0.6;
                        this.runs += 6;
                        if(this.currentBowler) this.currentBowler.matchRunsConceded += 6;
                        this.showCommentary("AI HITS A SIX!", true);
                        this.soundManager.playSound('six');
                        this.isReplayActive = true;
                        this.game3D.createExplosion(this.game3D.ball.position);
                    } else if (shotOutcome > 0.5) { // 30% chance of a four
                        this.ballVelocity.z = 0.7;
                        this.ballVelocity.y = 0.3;
                        this.runs += 4;
                        if(this.currentBowler) this.currentBowler.matchRunsConceded += 4;
                        this.showCommentary("AI HITS A FOUR!", true);
                        this.soundManager.playSound('four');
                        this.isReplayActive = true;
                    } else { // 50% chance of a single
                        this.ballVelocity.z = 0.4;
                        this.ballVelocity.y = 0.1;
                        this.runs += 1;
                        this.game3D.triggerRun(1);
                        if(this.currentBowler) this.currentBowler.matchRunsConceded += 1;
                        this.showCommentary("1 Run", false);
                        
                        // Swap AI Batsmen
                        const temp = this.currentBatsman;
                        this.currentBatsman = this.currentNonStriker;
                        this.currentNonStriker = temp;
                    }
                    this.ballVelocity.x = (Math.random() - 0.5) * 0.5;
                    this.updateScoreboard();
                } else {
                    // Missed - Check Wicket
                    const distToStumps = Math.abs(this.game3D.ball.position.x);
                    if(distToStumps < 0.3) {
                        if(this.isNoBall || this.isFreeHit) {
                            this.soundManager.playSound('umpireNotOut');
                            this.showCommentary("NOT OUT (" + (this.isNoBall ? "No Ball" : "Free Hit") + ")", true);
                            this.completeDelivery();
                            return;
                        }

                        if (this.isPracticeMode) {
                            this.showCommentary("Practice: Bowled!", true);
                            this.soundManager.playSound('wicket');
                            this.ballActive = false; // Stop ball
                            // Don't increment wickets, just complete delivery to continue
                            setTimeout(() => {
                                this.completeDelivery();
                            }, 2000);
                            return;
                        }

                        this.wickets++;
                        if(this.currentBowler) this.currentBowler.matchWickets++;
                        this.showCommentary("BOWLED HIM!", true);
                        this.soundManager.playSound('umpireOut');
                        this.isReplayActive = true;
                        this.soundManager.playSound('wicket'); // Play Wicket Sound
                        this.ballActive = false; // Stop ball
                        
                        // Update stats manually for AI Bowled
                        if(!this.isNoBall && !this.isWide) {
                            this.ballsBowled++;
                            if(this.currentBowler) this.currentBowler.matchBallsBowled++;
                        }
                        this.updateScoreboard();

                        // Check End of Over (Even if Wicket)
                        if(this.checkOverStatus()) isOverEnded = true;
                        
                        // AI All Out Check
                        if(this.wickets >= 10) {
                            setTimeout(() => this.endMatch(), 10000); // Replay Delay
                        } else {
                            // Continue Game (Reset for next ball)
                            if(isOverEnded) {
                                // Wait for selector
                                return;
                            }
                            setTimeout(() => {
                                this.ballActive = false;
                                this.game3D.ball.visible = false;
                            this.bowlingState = 'idle'; // State reset karein taaki agli delivery ho sake
                                this.showCommentary("Press Space to Bowl", false);
                            }, 10000); // Replay Delay
                        }
                    }
                }

                // AI Target Chase Check (User Bowling in 2nd Innings)
                if(this.target && this.runs >= this.target) {
                    setTimeout(() => this.endMatch(), 1000);
                }
            }

            swingBat(type) {
                if (!this.game3D.batsmanGroup) return; // Safety check
                const group = this.game3D.batsmanGroup;
                const handedness = group.userData.handedness || 'right';
                const swingDirection = (handedness === 'left') ? -1 : 1;
                const bat = group.userData.bat;
                if(bat) {
                    group.rotation.y = ((type === 'lofted') ? 1.5 : 0.8) * swingDirection;
                    bat.rotation.x = -1.5;
                    setTimeout(() => { 
                        if (!group) return;
                        const stanceRotation = (handedness === 'left') ? -0.2 : 0.2;
                        group.rotation.y = stanceRotation;
                        if (bat) bat.rotation.set(0.7, handedness === 'left' ? -0.1 : 0.1, handedness === 'left' ? 0.3 : -0.3);
                    }, 300);
                }

                // Collision Detection
                const ball = this.game3D.ball;
                if(this.ballActive && ball.position.z < -8 && ball.position.z > -11 && !this.isWide) {
                    // Check proximity to batsman
                    const dist = ball.position.distanceTo(this.game3D.batsmanGroup.position);
                    if(dist < 1.5) {
                        // HIT!
                        this.shotPlayed = true;
                        this.soundManager.playBatHit();
                        this.game3D.createExplosion(ball.position); // Visual feedback

                        if(!this.isNoBall) this.currentBatsman.matchBalls++;

                        // User Target Chase Check (User Batting in 2nd Innings)
                        if(this.target && (this.runs + 6) >= this.target) { 
                            // Will be checked after runs update, but good to know
                        }
                        
                        // Attributes
                        const power = this.currentBatsman.power || 70;
                        const timing = this.currentBatsman.timing || 70;
                        
                        // Skill-Based Timing Logic
                        const impactZ = -10; // Ideal impact point
                        const timingDiff = Math.abs(ball.position.z - impactZ);
                        let timingMult = 0.5;
                        let timingText = "MISTIMED";

                        if(timingDiff < 0.5) { timingMult = 1.5; timingText = "PERFECT!"; }
                        else if(timingDiff < 1.0) { timingMult = 1.0; timingText = "GOOD"; }
                        else { timingMult = 0.6; timingText = "EARLY/LATE"; }
                        
                        this.showCommentary(timingText, timingDiff < 0.5);

                        // Physics based on shot type
                        if(type === 'lofted') {
                            const oldRuns = this.currentBatsman.matchRuns || 0;
                            // Power check
                            const shotPower = (power / 100) * timingMult * (0.7 + Math.random() * 0.5);
                            
                            if (shotPower > 0.9) {
                                // SIX
                                this.ballVelocity.z = 0.9 + (shotPower * 0.2); // Fast
                                this.ballVelocity.y = 0.6 + (shotPower * 0.2); // High
                                this.runs += 6; 
                                this.currentBatsman.matchRuns += 6;
                                if(this.currentBowler) this.currentBowler.matchRunsConceded += 6;
                                this.showCommentary("HUGE SIX!", true);
                                if(this.isTargetMode) {
                                    this.targetScore += 6;
                                    this.showCommentary("SIX! (+6 Pts)", true);
                                } else {
                                    this.showCommentary("HUGE SIX!", true);
                                }
                                this.game3D.createExplosion(ball.position);
                                this.game3D.triggerShake(0.5);
                                this.isReplayActive = true; // Set replay flag
                                this.soundManager.playCheer();
                                this.game3D.launchFireworks(); // Fireworks for Six
                                this.soundManager.playSound('six'); // Play Six Sound
                            } else if (shotPower > 0.65) {
                                // FOUR
                                this.ballVelocity.z = 0.7;
                                this.ballVelocity.y = 0.3;
                                this.runs += 4;
                                this.currentBatsman.matchRuns += 4;
                                if(this.currentBowler) this.currentBowler.matchRunsConceded += 4;
                                this.game3D.triggerShake(0.2);
                                this.isReplayActive = true; // Set replay flag
                                this.showCommentary("FOUR RUNS!", true);
                                if(this.isTargetMode) {
                                    this.targetScore += 4;
                                    this.showCommentary("FOUR! (+4 Pts)", true);
                                } else {
                                    this.showCommentary("FOUR RUNS!", true);
                                }
                                this.game3D.launchFireworks(); // Fireworks
                                this.soundManager.playSound('four'); // Play Four Sound
                            } else {
                                // Mistimed - Caught
                                this.ballVelocity.z = 0.3; // Slower forward speed
                                this.ballVelocity.y = 0.5; // High up in the air
                                this.isPotentialCatch = true; // Flag for physics loop
                                this.showCommentary("IN THE AIR...", true);
                            }

                            if(oldRuns < 50 && this.currentBatsman.matchRuns >= 50) {
                                this.showCommentary(`FIFTY FOR ${this.currentBatsman.name.toUpperCase()}!`, true);
                                this.soundManager.playCheer();
                                this.game3D.celebrate50();
                            }
                        } else {
                            const oldRuns = this.currentBatsman.matchRuns || 0;
                            // Defensive
                            const shotPower = (timing / 100) * timingMult * (0.6 + Math.random() * 0.6);
                            this.ballVelocity.z = 0.4 + (shotPower * 0.2); // Slow
                            this.ballVelocity.y = 0.1; // Grounded
                            
                            if (shotPower > 0.85) {
                                this.runs += 4;
                                this.currentBatsman.matchRuns += 4;
                                if(this.currentBowler) this.currentBowler.matchRunsConceded += 4;
                                this.isReplayActive = true; // Set replay flag
                                this.showCommentary("CLASSY FOUR!", true);
                                if(this.isTargetMode) {
                                    this.targetScore += 4;
                                    this.showCommentary("FOUR! (+4 Pts)", true);
                                } else {
                                    this.showCommentary("CLASSY FOUR!", true);
                                }
                                this.game3D.launchFireworks(); // Fireworks
                                this.soundManager.playSound('four'); // Play Four Sound
                                this.game3D.triggerShake(0.2);
                                this.ballVelocity.z = 0.6;
                            } else if (shotPower > 0.5) {
                                const r = Math.floor(Math.random() * 3) + 1; // 1, 2, 3
                                this.runs += r;
                                this.currentBatsman.matchRuns += r;
                                if(this.currentBowler) this.currentBowler.matchRunsConceded += r;
                                this.showCommentary(r + " Runs", false);
                                this.soundManager.playSound('playerYes'); // Player calls for run
                                
                                // Swap batsmen on odd runs (1 or 3)
                                if (r % 2 !== 0 && this.currentNonStriker) {
                                    const temp = this.currentBatsman;
                                    this.currentBatsman = this.currentNonStriker;
                                    this.currentNonStriker = temp;
                                }
                                this.game3D.triggerRun(r);
                            } else {
                                this.soundManager.playSound(Math.random() > 0.5 ? 'playerNo' : 'playerWait'); // Player calls for no run/wait
                                this.showCommentary("Dot Ball", false);
                            }

                            if(oldRuns < 50 && this.currentBatsman.matchRuns >= 50) {
                                this.showCommentary(`FIFTY FOR ${this.currentBatsman.name.toUpperCase()}!`, true);
                                this.soundManager.playCheer();
                                this.game3D.celebrate50();
                            }
                        }
                        
                        // Direction Control
                        let dirX = (Math.random() - 0.5) * 0.2; // Default slight random
                        if(this.activeKeys['ArrowLeft']) dirX = -0.6; // Leg Side
                        if(this.activeKeys['ArrowRight']) dirX = 0.6; // Off Side
                        
                        if(this.activeKeys['ArrowDown']) {
                            // Scoop / Behind
                            this.ballVelocity.z = -0.5; // Go backwards
                            this.ballVelocity.y = 0.5; // High
                        }
                        this.ballVelocity.x = dirX;

                        console.log("SHOT!");
                        this.updateScoreboard();

                        // Check Win Condition immediately after shot
                        if(this.target && this.runs >= this.target) {
                            setTimeout(() => this.endMatch(), 2000);
                        }
                    }
                }
            }

            showCommentary(text, isBig) {
                const el = document.getElementById('commentary');
                el.innerText = text;
                el.style.opacity = 1;
                el.style.fontSize = isBig ? "5rem" : "3rem";
                el.style.color = isBig ? "#ffd700" : "#ffffff";
                setTimeout(() => { el.style.opacity = 0; }, 2000);
            }

            endMatch() {
                // Handle Innings Break
                if (this.innings === 1) {
                    this.innings = 2;
                    this.firstInningsScore = this.runs;
                    this.firstInningsWickets = this.wickets;
                    this.firstInningsRole = this.playerRole;
                    this.firstInningsBalls = this.ballsBowled;
                    this.isGameActive = false;
                    
                    const newTarget = this.runs + 1;
                    this.target = newTarget;
                    const nextRole = (this.playerRole === 'batting') ? 'bowling' : 'batting';
                    
                    alert(`Innings Break! Target: ${newTarget}`);
                    
                    if (nextRole === 'batting') {
                        this.playerRole = 'batting';
                        this.showBatsmanSelector('openers');
                    } else {
                        this.showBowlerSelector();
                    }
                    return;
                }

                // Game Over (2nd Innings Ended)
                this.isGameActive = false;
                let resultMsg = "";
                let won = false;
                
                let userRuns, userWickets, oppRuns, oppWickets;
                let userBalls, oppBalls;

                if (this.playerRole === 'batting') {
                    // User Chased
                    userRuns = this.runs; userWickets = this.wickets;
                    userBalls = this.ballsBowled;
                    oppRuns = this.firstInningsScore; oppWickets = this.firstInningsWickets;
                    oppBalls = this.firstInningsBalls;
                    
                    if(userRuns >= this.target) { resultMsg = "You Won by " + (10 - userWickets) + " wickets!"; won = true; }
                    else { resultMsg = "You Lost by " + (this.target - userRuns - 1) + " runs."; }
                    
                    // Check Tie
                    if(userRuns === this.target - 1) {
                        this.startSuperOver();
                        return;
                    }
                } else {
                    // User Defended
                    userRuns = this.firstInningsScore; userWickets = this.firstInningsWickets;
                    userBalls = this.firstInningsBalls;
                    oppRuns = this.runs; oppWickets = this.wickets;
                    oppBalls = this.ballsBowled;
                    
                    if(oppRuns >= this.target) { resultMsg = "You Lost by " + (10 - oppWickets) + " wickets."; }
                    else { resultMsg = "You Won by " + (this.target - oppRuns - 1) + " runs!"; won = true; }

                    // Check Tie
                    if(oppRuns === this.target - 1) {
                        this.startSuperOver();
                        return;
                    }
                }

                // --- Victory Animation ---
                const battingPlayers = [this.game3D.batsmanGroup, this.game3D.nonStrikerGroup];
                const fieldingPlayers = [this.game3D.bowlerGroup, ...this.game3D.fielders];

                let winningTeamPlayers = [];
                const wasUserBattingInFinalInnings = this.playerRole === 'batting';

                if (won) { // User team won
                    if (wasUserBattingInFinalInnings) {
                        winningTeamPlayers = battingPlayers;
                    } else {
                        winningTeamPlayers = fieldingPlayers;
                    }
                } else { // AI team won
                    if (wasUserBattingInFinalInnings) {
                        winningTeamPlayers = fieldingPlayers;
                    } else {
                        winningTeamPlayers = battingPlayers;
                    }
                }
                // Trigger animation for the winning team's players on the field
                this.game3D.triggerVictoryAnimation(winningTeamPlayers);

                // Update Stats
                const fullBalls = this.matchOvers * 6;
                const myTeam = TEAMS.find(t => t.id === this.userTeamId);
                const oppTeam = this.currentOpponent;

                if (myTeam) myTeam.played++;
                if (oppTeam) oppTeam.played++;
                
                // NRR Stats Update
                if (myTeam) {
                    myTeam.runsScored += userRuns;
                    myTeam.runsConceded += oppRuns;
                    myTeam.ballsFaced += (userWickets === 10) ? fullBalls : userBalls;
                    myTeam.ballsBowled += (oppWickets === 10) ? fullBalls : oppBalls;
                }
                if (oppTeam) {
                    oppTeam.runsScored += oppRuns;
                    oppTeam.runsConceded += userRuns;
                    oppTeam.ballsFaced += (oppWickets === 10) ? fullBalls : oppBalls;
                    oppTeam.ballsBowled += (userWickets === 10) ? fullBalls : userBalls;
                }

                if(won) { 
                    if (myTeam) { myTeam.won++; myTeam.pts += 2; }
                    this.soundManager.playSound('win'); // Play Win Sound
                } else {
                    // AI Won
                    if (oppTeam) { oppTeam.won++; oppTeam.pts += 2; }
                }

                // Tournament Stage Logic
                if (this.tournamentStage === 'semi-final') {
                    if (won) {
                        this.tournamentStage = 'final';
                        setTimeout(() => alert("üéâ You reached the FINAL! üéâ"), 1000);
                    } else {
                        this.tournamentStage = 'completed';
                        setTimeout(() => alert("‚ùå Knocked out in Semi-Finals!"), 1000);
                    }
                } else if (this.tournamentStage === 'final') {
                    this.tournamentStage = 'completed';
                    if (won) {
                        this.game3D.celebrateVictory();
                        setTimeout(() => alert("üèÜ CHAMPIONS! YOU WON THE IPL 2025! üèÜ"), 1000);
                    } else {
                        setTimeout(() => alert("ü•à Runner Up! Well played."), 1000);
                    }
                }
                
                // Delay summary screen to show victory animation
                setTimeout(() => {
                    this.showMatchSummary(resultMsg, userRuns, userWickets, oppRuns, oppWickets);
                    this.saveCareer(); // Save after match
                }, 10000); // 10 second delay
            }

            startSuperOver() {
                alert("MATCH TIED! Starting Super Over...");
                this.isSuperOver = true;
                this.innings = 1;
                this.runs = 0;
                this.wickets = 0;
                this.ballsBowled = 0;
                this.matchOvers = 1; // 1 Over only
                this.target = null;
                
                // Reset players for Super Over
                this.battedPlayers = [];
                this.resetMatchStats();
                
                // Start fresh toss/selection for Super Over
                this.showScreen('toss-screen');
                document.getElementById('toss-match-title').innerText = "SUPER OVER";
            }

            showMatchSummary(result, runs, wickets, oppRuns, oppWickets) {
                // --- AdSense Interstitial Trigger ---
                // An ad will be requested here. If available, it will show before the summary.
                triggerInterstitialAd();

                this.soundManager.stopCrowdLoop();
                this.showScreen('summary-screen');
                document.getElementById('summary-result').innerText = result;
                document.getElementById('summary-user-score').innerText = `${runs}/${wickets}`;
                document.getElementById('summary-opp-score').innerText = `${oppRuns}/${oppWickets}`;
                
                // Show Top Scorer
                let topScorer = "None";
                let topRuns = 0;
                
                // Top Bowler
                let topBowler = "None";
                let bestFigures = -999;
                let bestBowlerStats = "";

                // Player of the Match (Points based)
                let potm = "None";
                let maxPoints = -1;

                this.matchSquad.forEach(p => {
                    // Batting
                    if(p.matchRuns > topRuns) { topRuns = p.matchRuns; topScorer = p.name; }
                    
                    // Bowling (Weight: Wickets * 100 - Runs)
                    if(p.matchWickets !== undefined) {
                        const score = (p.matchWickets * 100) - (p.matchRunsConceded || 0);
                        if(score > bestFigures && (p.matchWickets > 0 || p.matchBallsBowled > 0)) {
                            bestFigures = score;
                            topBowler = p.name;
                            bestBowlerStats = `${p.matchWickets}-${p.matchRunsConceded}`;
                        }
                    }

                    // POTM Points: Runs + (Wickets * 25)
                    const pts = (p.matchRuns || 0) + ((p.matchWickets || 0) * 25);
                    if(pts > maxPoints) { maxPoints = pts; potm = p.name; }
                });
                
                document.getElementById('summary-stats').innerHTML = `
                    <p>Player of the Match: <b style="color: gold; font-size: 1.4rem;">${potm}</b></p>
                    <hr style="border-color: #444; margin: 10px 0;">
                    <p>Top Scorer: <b style="color: gold;">${topScorer}</b> (${topRuns} runs)</p>
                    <p>Top Bowler: <b style="color: gold;">${topBowler}</b> (${bestBowlerStats})</p>
                `;
            }
        }

        // Initialize Game Systems
        // This structure ensures that the game code only runs after the HTML document
        // is fully loaded. This prevents errors that can occur if a user interacts
        // with the UI before the scripts have finished parsing and initializing.
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // `auctionSystem` must be created first and assigned to the window object
                // because the `GameApp` constructor binds events that use it.
                window.auctionSystem = new AuctionSystem();
                window.gameApp = new GameApp();
            } catch (e) {
                console.error("Fatal Error: Failed to initialize the game systems.", e);
                // Display a user-friendly error if initialization fails catastrophically.
                document.body.innerHTML = '<div style="color:white; padding: 20px; text-align:center;"><h1>Error</h1><p>Could not start the game. Please try refreshing the page.</p></div>';
            }
        });

        // --- SYSTEM: Unit Testing ---
        window.runUnitTests = function() {
            console.clear();
            console.log("%cüèè RUNNING UNIT TESTS...", "color: gold; font-size: 16px; font-weight: bold; background: #333; padding: 5px; width: 100%;");
            
            let passed = 0, failed = 0;
            const assert = (condition, desc) => {
                if(condition) { 
                    console.log(`%c‚úÖ PASS: ${desc}`, "color: #4caf50"); 
                    passed++; 
                } else { 
                    console.error(`‚ùå FAIL: ${desc}`); 
                    failed++; 
                }
            };

            try {
                // 1. Player Data Integrity
                console.group("Player Data");
                const testPlayers = generateFullPlayerList();
                assert(testPlayers.length >= 300, "Generated 300+ players");
                assert(testPlayers[0].power >= 30 && testPlayers[0].power <= 99, "Power attribute within range");
                assert(testPlayers[0].timing >= 30 && testPlayers[0].timing <= 99, "Timing attribute within range");
                console.groupEnd();

                // 2. Auction Logic (Simulation)
                console.group("Auction System");
                const testAuction = new AuctionSystem();
                testAuction.userBudget = 120.0;
                testAuction.currentBid = 2.0;
                // Simulate Bid
                if(testAuction.userBudget >= testAuction.currentBid + 0.25) {
                    testAuction.currentBid += 0.25;
                    assert(testAuction.currentBid === 2.25, "Bid increment logic correct (+0.25)");
                }
                console.groupEnd();

                // 3. Game Logic (Math & State)
                console.group("Game Logic");
                // Overs Calculation
                const getOvers = (b) => Math.floor(b / 6) + "." + (b % 6);
                assert(getOvers(6) === "1.0", "6 balls = 1.0 overs");
                assert(getOvers(7) === "1.1", "7 balls = 1.1 overs");
                assert(getOvers(11) === "1.5", "11 balls = 1.5 overs");
                
                // Run Rate
                const rr = (r, b) => (b > 0) ? (r / (b/6)).toFixed(2) : "0.00";
                assert(rr(10, 6) === "10.00", "Run Rate (10 runs / 1 over)");
                assert(rr(15, 12) === "7.50", "Run Rate (15 runs / 2 overs)");
                console.groupEnd();

            } catch(e) {
                console.error("Test Suite Error:", e);
            }

            console.log(`%cüèÅ TESTS COMPLETED: ${passed} Passed, ${failed} Failed`, "font-weight: bold; padding: 5px; margin-top: 10px;");
        };

    </script>
</body>
</html>